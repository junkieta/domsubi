{
  "version": 3,
  "sources": ["../node_modules/typescript-collections/src/lib/util.ts", "../node_modules/typescript-collections/src/lib/arrays.ts", "../node_modules/typescript-collections/src/lib/Dictionary.ts", "../node_modules/typescript-collections/src/lib/Set.ts", "../node_modules/typescript-collections/src/lib/Bag.ts", "../node_modules/typescript-collections/src/lib/LinkedList.ts", "../node_modules/typescript-collections/src/lib/Queue.ts", "../node_modules/typescript-collections/src/lib/BSTreeKV.ts", "../node_modules/typescript-collections/src/lib/BSTree.ts", "../node_modules/typescript-collections/src/lib/Heap.ts", "../node_modules/typescript-collections/src/lib/LinkedDictionary.ts", "../node_modules/typescript-collections/src/lib/MultiDictionary.ts", "../node_modules/typescript-collections/src/lib/FactoryDictionary.ts", "../node_modules/typescript-collections/src/lib/PriorityQueue.ts", "../node_modules/typescript-collections/src/lib/Stack.ts", "../node_modules/typescript-collections/src/lib/MultiRootTree.ts", "../node_modules/typescript-collections/src/lib/index.ts", "../node_modules/sanctuary-type-identifiers/index.js", "../node_modules/sanctuary-type-classes/index.js", "../node_modules/sodiumjs/src/lib/sodium/Transaction.ts", "../node_modules/sodiumjs/src/lib/sodium/Vertex.ts", "../node_modules/sodiumjs/src/lib/sodium/Lambda.ts", "../node_modules/sodiumjs/src/lib/sodium/Lazy.ts", "../node_modules/sodiumjs/src/lib/sodium/Unit.ts", "../node_modules/sodiumjs/src/lib/sodium/Operational.ts", "../node_modules/sodiumjs/src/lib/sodium/Tuple2.ts", "../node_modules/sodiumjs/src/lib/sodium/Cell.ts", "../node_modules/sodiumjs/src/lib/sodium/Listener.ts", "../node_modules/sodiumjs/src/lib/sodium/LazyCell.ts", "../node_modules/sodiumjs/src/lib/sodium/Stream.ts", "../node_modules/sodiumjs/src/lib/sodium/CoalesceHandler.ts", "../node_modules/sodiumjs/src/lib/sodium/StreamSink.ts", "../node_modules/sodiumjs/src/lib/sodium/CellLoop.ts", "../node_modules/sodiumjs/src/lib/sodium/CellSink.ts", "../node_modules/sodiumjs/src/lib/sodium/Router.ts", "../node_modules/sodiumjs/src/lib/sodium/TimerSystem.ts", "../node_modules/sodiumjs/src/lib/sodium/SecondsTimerSystem.ts", "../node_modules/sodiumjs/src/lib/sodium/MillisecondsTimerSystem.ts", "../node_modules/sodiumjs/src/lib/sodium/IOAction.ts"],
  "sourcesContent": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, "/*\n        @@@@@@@            @@@@@@@         @@\n      @@       @@        @@       @@      @@@\n    @@   @@@ @@  @@    @@   @@@ @@  @@   @@@@@@ @@   @@@  @@ @@@      @@@@\n   @@  @@   @@@   @@  @@  @@   @@@   @@   @@@   @@   @@@  @@@   @@  @@@   @@\n   @@  @@   @@@   @@  @@  @@   @@@   @@   @@@   @@   @@@  @@@   @@  @@@@@@@@\n   @@  @@   @@@  @@   @@  @@   @@@  @@    @@@   @@   @@@  @@@   @@  @@@\n    @@   @@@ @@@@@     @@   @@@ @@@@@      @@@    @@@ @@  @@@@@@      @@@@@\n      @@                 @@                           @@  @@\n        @@@@@@@            @@@@@@@               @@@@@    @@\n                                                          */\n//. # sanctuary-type-identifiers\n//.\n//. A type is a set of values. Boolean, for example, is the type comprising\n//. `true` and `false`. A value may be a member of multiple types (`42` is a\n//. member of Number, PositiveNumber, Integer, and many other types).\n//.\n//. In certain situations it is useful to divide JavaScript values into\n//. non-overlapping types. The language provides two constructs for this\n//. purpose: the [`typeof`][1] operator and [`Object.prototype.toString`][2].\n//. Each has pros and cons, but neither supports user-defined types.\n//.\n//. This package specifies an [algorithm][3] for deriving a _type identifier_\n//. from any JavaScript value, and exports an implementation of the algorithm.\n//. Authors of algebraic data types may follow this specification in order to\n//. make their data types compatible with the algorithm.\n//.\n//. ### Algorithm\n//.\n//. 1.  Take any JavaScript value `x`.\n//.\n//. 2.  If `x` is `null` or `undefined`, go to step 6.\n//.\n//. 3.  If `x.constructor` evaluates to `null` or `undefined`, go to step 6.\n//.\n//. 4.  If `x.constructor.prototype === x`, go to step 6. This check prevents a\n//.     prototype object from being considered a member of its associated type.\n//.\n//. 5.  If `typeof x.constructor['@@type']` evaluates to `'string'`, return\n//.     the value of `x.constructor['@@type']`.\n//.\n//. 6.  Return the [`Object.prototype.toString`][2] representation of `x`\n//.     without the leading `'[object '` and trailing `']'`.\n//.\n//. ### Compatibility\n//.\n//. For an algebraic data type to be compatible with the [algorithm][3]:\n//.\n//.   - every member of the type must have a `constructor` property pointing\n//.     to an object known as the _type representative_;\n//.\n//.   - the type representative must have a `@@type` property; and\n//.\n//.   - the type representative's `@@type` property (the _type identifier_)\n//.     must be a string primitive, ideally `'<npm-package-name>/<type-name>'`.\n//.\n//. For example:\n//.\n//. ```javascript\n//. //  Identity :: a -> Identity a\n//. function Identity(x) {\n//.   if (!(this instanceof Identity)) return new Identity(x);\n//.   this.value = x;\n//. }\n//.\n//. Identity['@@type'] = 'my-package/Identity';\n//. ```\n//.\n//. Note that by using a constructor function the `constructor` property is set\n//. implicitly for each value created. Constructor functions are convenient for\n//. this reason, but are not required. This definition is also valid:\n//.\n//. ```javascript\n//. //  IdentityTypeRep :: TypeRep Identity\n//. var IdentityTypeRep = {\n//.   '@@type': 'my-package/Identity'\n//. };\n//.\n//. //  Identity :: a -> Identity a\n//. function Identity(x) {\n//.   return {constructor: IdentityTypeRep, value: x};\n//. }\n//. ```\n//.\n//. ### Usage\n//.\n//. ```javascript\n//. var Identity = require('my-package').Identity;\n//. var type = require('sanctuary-type-identifiers');\n//.\n//. type(null);         // => 'Null'\n//. type(true);         // => 'Boolean'\n//. type([1, 2, 3]);    // => 'Array'\n//. type(Identity);     // => 'Function'\n//. type(Identity(0));  // => 'my-package/Identity'\n//. ```\n//.\n//.\n//. [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof\n//. [2]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString\n//. [3]: #algorithm\n\n(function(f) {\n\n  'use strict';\n\n  if (typeof module === 'object' && typeof module.exports === 'object') {\n    module.exports = f();\n  } else if (typeof define === 'function' && define.amd != null) {\n    define([], f);\n  } else {\n    self.sanctuaryTypeIdentifiers = f();\n  }\n\n}(function() {\n\n  'use strict';\n\n  //  $$type :: String\n  var $$type = '@@type';\n\n  //  type :: Any -> String\n  function type(x) {\n    return x != null &&\n           x.constructor != null &&\n           x.constructor.prototype !== x &&\n           typeof x.constructor[$$type] === 'string' ?\n      x.constructor[$$type] :\n      Object.prototype.toString.call(x).slice('[object '.length, -']'.length);\n  }\n\n  return type;\n\n}));\n", "/*\n             ############                  #\n            ############                  ###\n                  #####                  #####\n                #####      ####################\n              #####       ######################\n            #####                     ###########\n          #####         ######################\n        #####          ####################\n      #####                        #####\n     ############                 ###\n    ############                 */\n\n//. # sanctuary-type-classes\n//.\n//. The [Fantasy Land Specification][FL] \"specifies interoperability of common\n//. algebraic structures\" by defining a number of type classes. For each type\n//. class, it states laws which every member of a type must obey in order for\n//. the type to be a member of the type class. In order for the Maybe type to\n//. be considered a [Functor][], for example, every `Maybe a` value must have\n//. a `fantasy-land/map` method which obeys the identity and composition laws.\n//.\n//. This project provides:\n//.\n//.   - [`TypeClass`](#TypeClass), a function for defining type classes;\n//.   - one `TypeClass` value for each Fantasy Land type class;\n//.   - lawful Fantasy Land methods for JavaScript's built-in types;\n//.   - one function for each Fantasy Land method; and\n//.   - several functions derived from these functions.\n//.\n//. ## Type-class hierarchy\n//.\n/* eslint-disable max-len */\n//. <pre>\n//.  Setoid   Semigroupoid  Semigroup   Foldable        Functor      Contravariant  Filterable\n//. (equals)    (compose)    (concat)   (reduce)         (map)        (contramap)    (filter)\n//.     |           |           |           \\         / | | | | \\\n//.     |           |           |            \\       /  | | | |  \\\n//.     |           |           |             \\     /   | | | |   \\\n//.     |           |           |              \\   /    | | | |    \\\n//.     |           |           |               \\ /     | | | |     \\\n//.    Ord      Category     Monoid         Traversable | | | |      \\\n//.   (lte)       (id)       (empty)        (traverse)  / | | \\       \\\n//.                             |                      /  | |  \\       \\\n//.                             |                     /   / \\   \\       \\\n//.                             |             Profunctor /   \\ Bifunctor \\\n//.                             |              (promap) /     \\ (bimap)   \\\n//.                             |                      /       \\           \\\n//.                           Group                   /         \\           \\\n//.                          (invert)               Alt        Apply      Extend\n//.                                                (alt)        (ap)     (extend)\n//.                                                 /           / \\           \\\n//.                                                /           /   \\           \\\n//.                                               /           /     \\           \\\n//.                                              /           /       \\           \\\n//.                                             /           /         \\           \\\n//.                                           Plus    Applicative    Chain      Comonad\n//.                                          (zero)       (of)      (chain)    (extract)\n//.                                             \\         / \\         / \\\n//.                                              \\       /   \\       /   \\\n//.                                               \\     /     \\     /     \\\n//.                                                \\   /       \\   /       \\\n//.                                                 \\ /         \\ /         \\\n//.                                             Alternative    Monad     ChainRec\n//.                                                                     (chainRec)\n//. </pre>\n/* eslint-enable max-len */\n//.\n//. ## API\n\n(function(f) {\n\n  'use strict';\n\n  /* istanbul ignore else */\n  if (typeof module === 'object' && typeof module.exports === 'object') {\n    module.exports = f(require('sanctuary-type-identifiers'));\n  } else if (typeof define === 'function' && define.amd != null) {\n    define(['sanctuary-type-identifiers'], f);\n  } else {\n    self.sanctuaryTypeClasses = f(self.sanctuaryTypeIdentifiers);\n  }\n\n}(function(type) {\n\n  'use strict';\n\n  /* istanbul ignore if */\n  if (typeof __doctest !== 'undefined') {\n    /* global __doctest:false */\n    /* eslint-disable no-unused-vars */\n    var Identity = __doctest.require('./test/Identity');\n    var List = __doctest.require('./test/List');\n    var Maybe = __doctest.require('./test/Maybe');\n    var Sum = __doctest.require('./test/Sum');\n    var Tuple = __doctest.require('./test/Tuple');\n\n    var Nil = List.Nil, Cons = List.Cons;\n    var Nothing = Maybe.Nothing, Just = Maybe.Just;\n    /* eslint-enable no-unused-vars */\n  }\n\n  //  concat_ :: Array a -> Array a -> Array a\n  function concat_(xs) {\n    return function(ys) {\n      return xs.concat(ys);\n    };\n  }\n\n  //  constant :: a -> b -> a\n  function constant(x) {\n    return function(y) {\n      return x;\n    };\n  }\n\n  //  forEachKey :: (StrMap a, StrMap a ~> String -> Undefined) -> Undefined\n  function forEachKey(strMap, f) {\n    Object.keys(strMap).forEach(f, strMap);\n  }\n\n  //  has :: (String, Object) -> Boolean\n  function has(k, o) {\n    return Object.prototype.hasOwnProperty.call(o, k);\n  }\n\n  //  identity :: a -> a\n  function identity(x) { return x; }\n\n  //  pair :: a -> b -> Array2 a b\n  function pair(x) {\n    return function(y) {\n      return [x, y];\n    };\n  }\n\n  //  sameType :: (a, b) -> Boolean\n  function sameType(x, y) {\n    return typeof x === typeof y && type(x) === type(y);\n  }\n\n  //  thrush :: a -> (a -> b) -> b\n  function thrush(x) {\n    return function(f) {\n      return f(x);\n    };\n  }\n\n  //  type Iteration a = { value :: a, done :: Boolean }\n\n  //  iterationNext :: a -> Iteration a\n  function iterationNext(x) { return {value: x, done: false}; }\n\n  //  iterationDone :: a -> Iteration a\n  function iterationDone(x) { return {value: x, done: true}; }\n\n  //# TypeClass :: (String, String, Array TypeClass, a -> Boolean) -> TypeClass\n  //.\n  //. The arguments are:\n  //.\n  //.   - the name of the type class, prefixed by its npm package name;\n  //.   - the documentation URL of the type class;\n  //.   - an array of dependencies; and\n  //.   - a predicate which accepts any JavaScript value and returns `true`\n  //.     if the value satisfies the requirements of the type class; `false`\n  //.     otherwise.\n  //.\n  //. Example:\n  //.\n  //. ```javascript\n  //. //    hasMethod :: String -> a -> Boolean\n  //. const hasMethod = name => x => x != null && typeof x[name] == 'function';\n  //.\n  //. //    Foo :: TypeClass\n  //. const Foo = Z.TypeClass(\n  //.   'my-package/Foo',\n  //.   'http://example.com/my-package#Foo',\n  //.   [],\n  //.   hasMethod('foo')\n  //. );\n  //.\n  //. //    Bar :: TypeClass\n  //. const Bar = Z.TypeClass(\n  //.   'my-package/Bar',\n  //.   'http://example.com/my-package#Bar',\n  //.   [Foo],\n  //.   hasMethod('bar')\n  //. );\n  //. ```\n  //.\n  //. Types whose values have a `foo` method are members of the Foo type class.\n  //. Members of the Foo type class whose values have a `bar` method are also\n  //. members of the Bar type class.\n  //.\n  //. Each `TypeClass` value has a `test` field: a function which accepts\n  //. any JavaScript value and returns `true` if the value satisfies the\n  //. type class's predicate and the predicates of all the type class's\n  //. dependencies; `false` otherwise.\n  //.\n  //. `TypeClass` values may be used with [sanctuary-def][type-classes]\n  //. to define parametrically polymorphic functions which verify their\n  //. type-class constraints at run time.\n  function TypeClass(name, url, dependencies, test) {\n    if (!(this instanceof TypeClass)) {\n      return new TypeClass(name, url, dependencies, test);\n    }\n    this.name = name;\n    this.url = url;\n    this.test = function(x) {\n      return dependencies.every(function(d) { return d.test(x); }) && test(x);\n    };\n  }\n\n  TypeClass['@@type'] = 'sanctuary-type-classes/TypeClass';\n\n  //  data Location = Constructor | Value\n\n  //  Constructor :: Location\n  var Constructor = 'Constructor';\n\n  //  Value :: Location\n  var Value = 'Value';\n\n  //  _funcPath :: (Boolean, Array String, a) -> Nullable Function\n  function _funcPath(allowInheritedProps, path, _x) {\n    var x = _x;\n    for (var idx = 0; idx < path.length; idx += 1) {\n      var k = path[idx];\n      if (x == null || !(allowInheritedProps || has(k, x))) return null;\n      x = x[k];\n    }\n    return typeof x === 'function' ? x : null;\n  }\n\n  //  funcPath :: (Array String, a) -> Nullable Function\n  function funcPath(path, x) {\n    return _funcPath(true, path, x);\n  }\n\n  //  implPath :: Array String -> Nullable Function\n  function implPath(path) {\n    return _funcPath(false, path, implementations);\n  }\n\n  //  functionName :: Function -> String\n  var functionName = has('name', function f() {}) ?\n    function functionName(f) { return f.name; } :\n    /* istanbul ignore next */\n    function functionName(f) {\n      var match = /function (\\w*)/.exec(f);\n      return match == null ? '' : match[1];\n    };\n\n  //  $ :: (String, Array TypeClass, StrMap (Array Location)) -> TypeClass\n  function $(_name, dependencies, requirements) {\n    function getBoundMethod(_name) {\n      var name = 'fantasy-land/' + _name;\n      return requirements[_name] === Constructor ?\n        function(typeRep) {\n          var f = funcPath([name], typeRep);\n          return f == null && typeof typeRep === 'function' ?\n            implPath([functionName(typeRep), name]) :\n            f;\n        } :\n        function(x) {\n          var isPrototype = x != null &&\n                            x.constructor != null &&\n                            x.constructor.prototype === x;\n          var m = null;\n          if (!isPrototype) m = funcPath([name], x);\n          if (m == null)    m = implPath([type(x), 'prototype', name]);\n          return m && m.bind(x);\n        };\n    }\n\n    var version = '9.0.0';  // updated programmatically\n    var keys = Object.keys(requirements);\n\n    var typeClass = TypeClass(\n      'sanctuary-type-classes/' + _name,\n      'https://github.com/sanctuary-js/sanctuary-type-classes/tree/v' + version\n        + '#' + _name,\n      dependencies,\n      function(x) {\n        return keys.every(function(_name) {\n          var arg = requirements[_name] === Constructor ? x.constructor : x;\n          return getBoundMethod(_name)(arg) != null;\n        });\n      }\n    );\n\n    typeClass.methods = keys.reduce(function(methods, _name) {\n      methods[_name] = getBoundMethod(_name);\n      return methods;\n    }, {});\n\n    return typeClass;\n  }\n\n  //# Setoid :: TypeClass\n  //.\n  //. `TypeClass` value for [Setoid][].\n  //.\n  //. ```javascript\n  //. > Setoid.test(null)\n  //. true\n  //. ```\n  var Setoid = $('Setoid', [], {equals: Value});\n\n  //# Ord :: TypeClass\n  //.\n  //. `TypeClass` value for [Ord][].\n  //.\n  //. ```javascript\n  //. > Ord.test(0)\n  //. true\n  //.\n  //. > Ord.test(Math.sqrt)\n  //. false\n  //. ```\n  var Ord = $('Ord', [Setoid], {lte: Value});\n\n  //# Semigroupoid :: TypeClass\n  //.\n  //. `TypeClass` value for [Semigroupoid][].\n  //.\n  //. ```javascript\n  //. > Semigroupoid.test(Math.sqrt)\n  //. true\n  //.\n  //. > Semigroupoid.test(0)\n  //. false\n  //. ```\n  var Semigroupoid = $('Semigroupoid', [], {compose: Value});\n\n  //# Category :: TypeClass\n  //.\n  //. `TypeClass` value for [Category][].\n  //.\n  //. ```javascript\n  //. > Category.test(Math.sqrt)\n  //. true\n  //.\n  //. > Category.test(0)\n  //. false\n  //. ```\n  var Category = $('Category', [Semigroupoid], {id: Constructor});\n\n  //# Semigroup :: TypeClass\n  //.\n  //. `TypeClass` value for [Semigroup][].\n  //.\n  //. ```javascript\n  //. > Semigroup.test('')\n  //. true\n  //.\n  //. > Semigroup.test(0)\n  //. false\n  //. ```\n  var Semigroup = $('Semigroup', [], {concat: Value});\n\n  //# Monoid :: TypeClass\n  //.\n  //. `TypeClass` value for [Monoid][].\n  //.\n  //. ```javascript\n  //. > Monoid.test('')\n  //. true\n  //.\n  //. > Monoid.test(0)\n  //. false\n  //. ```\n  var Monoid = $('Monoid', [Semigroup], {empty: Constructor});\n\n  //# Group :: TypeClass\n  //.\n  //. `TypeClass` value for [Group][].\n  //.\n  //. ```javascript\n  //. > Group.test(Sum(0))\n  //. true\n  //.\n  //. > Group.test('')\n  //. false\n  //. ```\n  var Group = $('Group', [Monoid], {invert: Value});\n\n  //# Filterable :: TypeClass\n  //.\n  //. `TypeClass` value for [Filterable][].\n  //.\n  //. ```javascript\n  //. > Filterable.test({})\n  //. true\n  //.\n  //. > Filterable.test('')\n  //. false\n  //. ```\n  var Filterable = $('Filterable', [], {filter: Value});\n\n  //# Functor :: TypeClass\n  //.\n  //. `TypeClass` value for [Functor][].\n  //.\n  //. ```javascript\n  //. > Functor.test([])\n  //. true\n  //.\n  //. > Functor.test('')\n  //. false\n  //. ```\n  var Functor = $('Functor', [], {map: Value});\n\n  //# Bifunctor :: TypeClass\n  //.\n  //. `TypeClass` value for [Bifunctor][].\n  //.\n  //. ```javascript\n  //. > Bifunctor.test(Tuple('foo', 64))\n  //. true\n  //.\n  //. > Bifunctor.test([])\n  //. false\n  //. ```\n  var Bifunctor = $('Bifunctor', [Functor], {bimap: Value});\n\n  //# Profunctor :: TypeClass\n  //.\n  //. `TypeClass` value for [Profunctor][].\n  //.\n  //. ```javascript\n  //. > Profunctor.test(Math.sqrt)\n  //. true\n  //.\n  //. > Profunctor.test([])\n  //. false\n  //. ```\n  var Profunctor = $('Profunctor', [Functor], {promap: Value});\n\n  //# Apply :: TypeClass\n  //.\n  //. `TypeClass` value for [Apply][].\n  //.\n  //. ```javascript\n  //. > Apply.test([])\n  //. true\n  //.\n  //. > Apply.test('')\n  //. false\n  //. ```\n  var Apply = $('Apply', [Functor], {ap: Value});\n\n  //# Applicative :: TypeClass\n  //.\n  //. `TypeClass` value for [Applicative][].\n  //.\n  //. ```javascript\n  //. > Applicative.test([])\n  //. true\n  //.\n  //. > Applicative.test({})\n  //. false\n  //. ```\n  var Applicative = $('Applicative', [Apply], {of: Constructor});\n\n  //# Chain :: TypeClass\n  //.\n  //. `TypeClass` value for [Chain][].\n  //.\n  //. ```javascript\n  //. > Chain.test([])\n  //. true\n  //.\n  //. > Chain.test({})\n  //. false\n  //. ```\n  var Chain = $('Chain', [Apply], {chain: Value});\n\n  //# ChainRec :: TypeClass\n  //.\n  //. `TypeClass` value for [ChainRec][].\n  //.\n  //. ```javascript\n  //. > ChainRec.test([])\n  //. true\n  //.\n  //. > ChainRec.test({})\n  //. false\n  //. ```\n  var ChainRec = $('ChainRec', [Chain], {chainRec: Constructor});\n\n  //# Monad :: TypeClass\n  //.\n  //. `TypeClass` value for [Monad][].\n  //.\n  //. ```javascript\n  //. > Monad.test([])\n  //. true\n  //.\n  //. > Monad.test({})\n  //. false\n  //. ```\n  var Monad = $('Monad', [Applicative, Chain], {});\n\n  //# Alt :: TypeClass\n  //.\n  //. `TypeClass` value for [Alt][].\n  //.\n  //. ```javascript\n  //. > Alt.test({})\n  //. true\n  //.\n  //. > Alt.test('')\n  //. false\n  //. ```\n  var Alt = $('Alt', [Functor], {alt: Value});\n\n  //# Plus :: TypeClass\n  //.\n  //. `TypeClass` value for [Plus][].\n  //.\n  //. ```javascript\n  //. > Plus.test({})\n  //. true\n  //.\n  //. > Plus.test('')\n  //. false\n  //. ```\n  var Plus = $('Plus', [Alt], {zero: Constructor});\n\n  //# Alternative :: TypeClass\n  //.\n  //. `TypeClass` value for [Alternative][].\n  //.\n  //. ```javascript\n  //. > Alternative.test([])\n  //. true\n  //.\n  //. > Alternative.test({})\n  //. false\n  //. ```\n  var Alternative = $('Alternative', [Applicative, Plus], {});\n\n  //# Foldable :: TypeClass\n  //.\n  //. `TypeClass` value for [Foldable][].\n  //.\n  //. ```javascript\n  //. > Foldable.test({})\n  //. true\n  //.\n  //. > Foldable.test('')\n  //. false\n  //. ```\n  var Foldable = $('Foldable', [], {reduce: Value});\n\n  //# Traversable :: TypeClass\n  //.\n  //. `TypeClass` value for [Traversable][].\n  //.\n  //. ```javascript\n  //. > Traversable.test([])\n  //. true\n  //.\n  //. > Traversable.test('')\n  //. false\n  //. ```\n  var Traversable = $('Traversable', [Functor, Foldable], {traverse: Value});\n\n  //# Extend :: TypeClass\n  //.\n  //. `TypeClass` value for [Extend][].\n  //.\n  //. ```javascript\n  //. > Extend.test([])\n  //. true\n  //.\n  //. > Extend.test({})\n  //. false\n  //. ```\n  var Extend = $('Extend', [Functor], {extend: Value});\n\n  //# Comonad :: TypeClass\n  //.\n  //. `TypeClass` value for [Comonad][].\n  //.\n  //. ```javascript\n  //. > Comonad.test(Identity(0))\n  //. true\n  //.\n  //. > Comonad.test([])\n  //. false\n  //. ```\n  var Comonad = $('Comonad', [Extend], {extract: Value});\n\n  //# Contravariant :: TypeClass\n  //.\n  //. `TypeClass` value for [Contravariant][].\n  //.\n  //. ```javascript\n  //. > Contravariant.test(Math.sqrt)\n  //. true\n  //.\n  //. > Contravariant.test([])\n  //. false\n  //. ```\n  var Contravariant = $('Contravariant', [], {contramap: Value});\n\n  //  Null$prototype$equals :: Null ~> Null -> Boolean\n  function Null$prototype$equals(other) {\n    return true;\n  }\n\n  //  Null$prototype$lte :: Null ~> Null -> Boolean\n  function Null$prototype$lte(other) {\n    return true;\n  }\n\n  //  Undefined$prototype$equals :: Undefined ~> Undefined -> Boolean\n  function Undefined$prototype$equals(other) {\n    return true;\n  }\n\n  //  Undefined$prototype$lte :: Undefined ~> Undefined -> Boolean\n  function Undefined$prototype$lte(other) {\n    return true;\n  }\n\n  //  Boolean$prototype$equals :: Boolean ~> Boolean -> Boolean\n  function Boolean$prototype$equals(other) {\n    return typeof this === 'object' ?\n      equals(this.valueOf(), other.valueOf()) :\n      this === other;\n  }\n\n  //  Boolean$prototype$lte :: Boolean ~> Boolean -> Boolean\n  function Boolean$prototype$lte(other) {\n    return typeof this === 'object' ?\n      lte(this.valueOf(), other.valueOf()) :\n      this === false || other === true;\n  }\n\n  //  Number$prototype$equals :: Number ~> Number -> Boolean\n  function Number$prototype$equals(other) {\n    return typeof this === 'object' ?\n      equals(this.valueOf(), other.valueOf()) :\n      isNaN(this) && isNaN(other) || this === other;\n  }\n\n  //  Number$prototype$lte :: Number ~> Number -> Boolean\n  function Number$prototype$lte(other) {\n    return typeof this === 'object' ?\n      lte(this.valueOf(), other.valueOf()) :\n      isNaN(this) || this <= other;\n  }\n\n  //  Date$prototype$equals :: Date ~> Date -> Boolean\n  function Date$prototype$equals(other) {\n    return equals(this.valueOf(), other.valueOf());\n  }\n\n  //  Date$prototype$lte :: Date ~> Date -> Boolean\n  function Date$prototype$lte(other) {\n    return lte(this.valueOf(), other.valueOf());\n  }\n\n  //  RegExp$prototype$equals :: RegExp ~> RegExp -> Boolean\n  function RegExp$prototype$equals(other) {\n    return other.source === this.source &&\n           other.global === this.global &&\n           other.ignoreCase === this.ignoreCase &&\n           other.multiline === this.multiline &&\n           other.sticky === this.sticky &&\n           other.unicode === this.unicode;\n  }\n\n  //  String$empty :: () -> String\n  function String$empty() {\n    return '';\n  }\n\n  //  String$prototype$equals :: String ~> String -> Boolean\n  function String$prototype$equals(other) {\n    return typeof this === 'object' ?\n      equals(this.valueOf(), other.valueOf()) :\n      this === other;\n  }\n\n  //  String$prototype$lte :: String ~> String -> Boolean\n  function String$prototype$lte(other) {\n    return typeof this === 'object' ?\n      lte(this.valueOf(), other.valueOf()) :\n      this <= other;\n  }\n\n  //  String$prototype$concat :: String ~> String -> String\n  function String$prototype$concat(other) {\n    return this + other;\n  }\n\n  //  Array$empty :: () -> Array a\n  function Array$empty() {\n    return [];\n  }\n\n  //  Array$of :: a -> Array a\n  function Array$of(x) {\n    return [x];\n  }\n\n  //  Array$chainRec :: ((a -> c, b -> c, a) -> Array c, a) -> Array b\n  function Array$chainRec(f, x) {\n    var result = [];\n    var nil = {};\n    var todo = {head: x, tail: nil};\n    while (todo !== nil) {\n      var more = nil;\n      var steps = f(iterationNext, iterationDone, todo.head);\n      for (var idx = 0; idx < steps.length; idx += 1) {\n        var step = steps[idx];\n        if (step.done) {\n          result.push(step.value);\n        } else {\n          more = {head: step.value, tail: more};\n        }\n      }\n      todo = todo.tail;\n      while (more !== nil) {\n        todo = {head: more.head, tail: todo};\n        more = more.tail;\n      }\n    }\n    return result;\n  }\n\n  //  Array$zero :: () -> Array a\n  function Array$zero() {\n    return [];\n  }\n\n  //  Array$prototype$equals :: Array a ~> Array a -> Boolean\n  function Array$prototype$equals(other) {\n    if (other.length !== this.length) return false;\n    for (var idx = 0; idx < this.length; idx += 1) {\n      if (!equals(this[idx], other[idx])) return false;\n    }\n    return true;\n  }\n\n  //  Array$prototype$lte :: Array a ~> Array a -> Boolean\n  function Array$prototype$lte(other) {\n    for (var idx = 0; true; idx += 1) {\n      if (idx === this.length) return true;\n      if (idx === other.length) return false;\n      if (!equals(this[idx], other[idx])) return lte(this[idx], other[idx]);\n    }\n  }\n\n  //  Array$prototype$concat :: Array a ~> Array a -> Array a\n  function Array$prototype$concat(other) {\n    return this.concat(other);\n  }\n\n  //  Array$prototype$filter :: Array a ~> (a -> Boolean) -> Array a\n  function Array$prototype$filter(pred) {\n    return this.filter(function(x) { return pred(x); });\n  }\n\n  //  Array$prototype$map :: Array a ~> (a -> b) -> Array b\n  function Array$prototype$map(f) {\n    return this.map(function(x) { return f(x); });\n  }\n\n  //  Array$prototype$ap :: Array a ~> Array (a -> b) -> Array b\n  function Array$prototype$ap(fs) {\n    var result = [];\n    for (var idx = 0; idx < fs.length; idx += 1) {\n      for (var idx2 = 0; idx2 < this.length; idx2 += 1) {\n        result.push(fs[idx](this[idx2]));\n      }\n    }\n    return result;\n  }\n\n  //  Array$prototype$chain :: Array a ~> (a -> Array b) -> Array b\n  function Array$prototype$chain(f) {\n    var result = [];\n    for (var idx = 0; idx < this.length; idx += 1) {\n      for (var idx2 = 0, xs = f(this[idx]); idx2 < xs.length; idx2 += 1) {\n        result.push(xs[idx2]);\n      }\n    }\n    return result;\n  }\n\n  //  Array$prototype$alt :: Array a ~> Array a -> Array a\n  var Array$prototype$alt = Array$prototype$concat;\n\n  //  Array$prototype$reduce :: Array a ~> ((b, a) -> b, b) -> b\n  function Array$prototype$reduce(f, initial) {\n    var acc = initial;\n    for (var idx = 0; idx < this.length; idx += 1) acc = f(acc, this[idx]);\n    return acc;\n  }\n\n  //  Array$prototype$traverse :: Applicative f => Array a ~> (TypeRep f, a -> f b) -> f (Array b)\n  function Array$prototype$traverse(typeRep, f) {\n    var xs = this;\n    function go(idx, n) {\n      switch (n) {\n        case 0: return of(typeRep, []);\n        case 2: return lift2(pair, f(xs[idx]), f(xs[idx + 1]));\n        default:\n          var m = Math.floor(n / 4) * 2;\n          return lift2(concat_, go(idx, m), go(idx + m, n - m));\n      }\n    }\n    return this.length % 2 === 1 ?\n      lift2(concat_, map(Array$of, f(this[0])), go(1, this.length - 1)) :\n      go(0, this.length);\n  }\n\n  //  Array$prototype$extend :: Array a ~> (Array a -> b) -> Array b\n  function Array$prototype$extend(f) {\n    return this.map(function(_, idx, xs) { return f(xs.slice(idx)); });\n  }\n\n  //  Arguments$prototype$equals :: Arguments ~> Arguments -> Boolean\n  function Arguments$prototype$equals(other) {\n    return Array$prototype$equals.call(this, other);\n  }\n\n  //  Arguments$prototype$lte :: Arguments ~> Arguments -> Boolean\n  function Arguments$prototype$lte(other) {\n    return Array$prototype$lte.call(this, other);\n  }\n\n  //  Error$prototype$equals :: Error ~> Error -> Boolean\n  function Error$prototype$equals(other) {\n    return equals(this.name, other.name) &&\n           equals(this.message, other.message);\n  }\n\n  //  Object$empty :: () -> StrMap a\n  function Object$empty() {\n    return {};\n  }\n\n  //  Object$zero :: () -> StrMap a\n  function Object$zero() {\n    return {};\n  }\n\n  //  Object$prototype$equals :: StrMap a ~> StrMap a -> Boolean\n  function Object$prototype$equals(other) {\n    var self = this;\n    var keys = Object.keys(this).sort();\n    return equals(keys, Object.keys(other).sort()) &&\n           keys.every(function(k) { return equals(self[k], other[k]); });\n  }\n\n  //  Object$prototype$lte :: StrMap a ~> StrMap a -> Boolean\n  function Object$prototype$lte(other) {\n    var theseKeys = Object.keys(this).sort();\n    var otherKeys = Object.keys(other).sort();\n    while (true) {\n      if (theseKeys.length === 0) return true;\n      if (otherKeys.length === 0) return false;\n      var k = theseKeys.shift();\n      var z = otherKeys.shift();\n      if (k < z) return true;\n      if (k > z) return false;\n      if (!equals(this[k], other[k])) return lte(this[k], other[k]);\n    }\n  }\n\n  //  Object$prototype$concat :: StrMap a ~> StrMap a -> StrMap a\n  function Object$prototype$concat(other) {\n    var result = {};\n    function assign(k) { result[k] = this[k]; }\n    forEachKey(this, assign);\n    forEachKey(other, assign);\n    return result;\n  }\n\n  //  Object$prototype$filter :: StrMap a ~> (a -> Boolean) -> StrMap a\n  function Object$prototype$filter(pred) {\n    var result = {};\n    forEachKey(this, function(k) { if (pred(this[k])) result[k] = this[k]; });\n    return result;\n  }\n\n  //  Object$prototype$map :: StrMap a ~> (a -> b) -> StrMap b\n  function Object$prototype$map(f) {\n    var result = {};\n    forEachKey(this, function(k) { result[k] = f(this[k]); });\n    return result;\n  }\n\n  //  Object$prototype$ap :: StrMap a ~> StrMap (a -> b) -> StrMap b\n  function Object$prototype$ap(other) {\n    var result = {};\n    forEachKey(this, function(k) {\n      if (has(k, other)) result[k] = other[k](this[k]);\n    });\n    return result;\n  }\n\n  //  Object$prototype$alt :: StrMap a ~> StrMap a -> StrMap a\n  var Object$prototype$alt = Object$prototype$concat;\n\n  //  Object$prototype$reduce :: StrMap a ~> ((b, a) -> b, b) -> b\n  function Object$prototype$reduce(f, initial) {\n    var self = this;\n    function reducer(acc, k) { return f(acc, self[k]); }\n    return Object.keys(this).sort().reduce(reducer, initial);\n  }\n\n  //  Object$prototype$traverse :: Applicative f => StrMap a ~> (TypeRep f, a -> f b) -> f (StrMap b)\n  function Object$prototype$traverse(typeRep, f) {\n    var self = this;\n    return Object.keys(this).reduce(function(applicative, k) {\n      function set(o) {\n        return function(v) {\n          var singleton = {}; singleton[k] = v;\n          return Object$prototype$concat.call(o, singleton);\n        };\n      }\n      return lift2(set, applicative, f(self[k]));\n    }, of(typeRep, {}));\n  }\n\n  //  Function$id :: () -> a -> a\n  function Function$id() {\n    return identity;\n  }\n\n  //  Function$of :: b -> (a -> b)\n  function Function$of(x) {\n    return function(_) { return x; };\n  }\n\n  //  Function$chainRec :: ((a -> c, b -> c, a) -> (z -> c), a) -> (z -> b)\n  function Function$chainRec(f, x) {\n    return function(a) {\n      var step = iterationNext(x);\n      while (!step.done) {\n        step = f(iterationNext, iterationDone, step.value)(a);\n      }\n      return step.value;\n    };\n  }\n\n  //  Function$prototype$equals :: Function ~> Function -> Boolean\n  function Function$prototype$equals(other) {\n    return other === this;\n  }\n\n  //  Function$prototype$compose :: (a -> b) ~> (b -> c) -> (a -> c)\n  function Function$prototype$compose(other) {\n    var semigroupoid = this;\n    return function(x) { return other(semigroupoid(x)); };\n  }\n\n  //  Function$prototype$map :: (a -> b) ~> (b -> c) -> (a -> c)\n  function Function$prototype$map(f) {\n    var functor = this;\n    return function(x) { return f(functor(x)); };\n  }\n\n  //  Function$prototype$promap :: (b -> c) ~> (a -> b, c -> d) -> (a -> d)\n  function Function$prototype$promap(f, g) {\n    var profunctor = this;\n    return function(x) { return g(profunctor(f(x))); };\n  }\n\n  //  Function$prototype$ap :: (a -> b) ~> (a -> b -> c) -> (a -> c)\n  function Function$prototype$ap(f) {\n    var apply = this;\n    return function(x) { return f(x)(apply(x)); };\n  }\n\n  //  Function$prototype$chain :: (a -> b) ~> (b -> a -> c) -> (a -> c)\n  function Function$prototype$chain(f) {\n    var chain = this;\n    return function(x) { return f(chain(x))(x); };\n  }\n\n  //  Function$prototype$extend :: Semigroup a => (a -> b) ~> ((a -> b) -> c) -> (a -> c)\n  function Function$prototype$extend(f) {\n    var extend = this;\n    return function(x) {\n      return f(function(y) { return extend(concat(x, y)); });\n    };\n  }\n\n  //  Function$prototype$contramap :: (b -> c) ~> (a -> b) -> (a -> c)\n  function Function$prototype$contramap(f) {\n    var contravariant = this;\n    return function(x) { return contravariant(f(x)); };\n  }\n\n  /* eslint-disable key-spacing */\n  var implementations = {\n    Null: {\n      'prototype': {\n        'fantasy-land/equals':      Null$prototype$equals,\n        'fantasy-land/lte':         Null$prototype$lte\n      }\n    },\n    Undefined: {\n      'prototype': {\n        'fantasy-land/equals':      Undefined$prototype$equals,\n        'fantasy-land/lte':         Undefined$prototype$lte\n      }\n    },\n    Boolean: {\n      'prototype': {\n        'fantasy-land/equals':      Boolean$prototype$equals,\n        'fantasy-land/lte':         Boolean$prototype$lte\n      }\n    },\n    Number: {\n      'prototype': {\n        'fantasy-land/equals':      Number$prototype$equals,\n        'fantasy-land/lte':         Number$prototype$lte\n      }\n    },\n    Date: {\n      'prototype': {\n        'fantasy-land/equals':      Date$prototype$equals,\n        'fantasy-land/lte':         Date$prototype$lte\n      }\n    },\n    RegExp: {\n      'prototype': {\n        'fantasy-land/equals':      RegExp$prototype$equals\n      }\n    },\n    String: {\n      'fantasy-land/empty':         String$empty,\n      'prototype': {\n        'fantasy-land/equals':      String$prototype$equals,\n        'fantasy-land/lte':         String$prototype$lte,\n        'fantasy-land/concat':      String$prototype$concat\n      }\n    },\n    Array: {\n      'fantasy-land/empty':         Array$empty,\n      'fantasy-land/of':            Array$of,\n      'fantasy-land/chainRec':      Array$chainRec,\n      'fantasy-land/zero':          Array$zero,\n      'prototype': {\n        'fantasy-land/equals':      Array$prototype$equals,\n        'fantasy-land/lte':         Array$prototype$lte,\n        'fantasy-land/concat':      Array$prototype$concat,\n        'fantasy-land/filter':      Array$prototype$filter,\n        'fantasy-land/map':         Array$prototype$map,\n        'fantasy-land/ap':          Array$prototype$ap,\n        'fantasy-land/chain':       Array$prototype$chain,\n        'fantasy-land/alt':         Array$prototype$alt,\n        'fantasy-land/reduce':      Array$prototype$reduce,\n        'fantasy-land/traverse':    Array$prototype$traverse,\n        'fantasy-land/extend':      Array$prototype$extend\n      }\n    },\n    Arguments: {\n      'prototype': {\n        'fantasy-land/equals':      Arguments$prototype$equals,\n        'fantasy-land/lte':         Arguments$prototype$lte\n      }\n    },\n    Error: {\n      'prototype': {\n        'fantasy-land/equals':      Error$prototype$equals\n      }\n    },\n    Object: {\n      'fantasy-land/empty':         Object$empty,\n      'fantasy-land/zero':          Object$zero,\n      'prototype': {\n        'fantasy-land/equals':      Object$prototype$equals,\n        'fantasy-land/lte':         Object$prototype$lte,\n        'fantasy-land/concat':      Object$prototype$concat,\n        'fantasy-land/filter':      Object$prototype$filter,\n        'fantasy-land/map':         Object$prototype$map,\n        'fantasy-land/ap':          Object$prototype$ap,\n        'fantasy-land/alt':         Object$prototype$alt,\n        'fantasy-land/reduce':      Object$prototype$reduce,\n        'fantasy-land/traverse':    Object$prototype$traverse\n      }\n    },\n    Function: {\n      'fantasy-land/id':            Function$id,\n      'fantasy-land/of':            Function$of,\n      'fantasy-land/chainRec':      Function$chainRec,\n      'prototype': {\n        'fantasy-land/equals':      Function$prototype$equals,\n        'fantasy-land/compose':     Function$prototype$compose,\n        'fantasy-land/map':         Function$prototype$map,\n        'fantasy-land/promap':      Function$prototype$promap,\n        'fantasy-land/ap':          Function$prototype$ap,\n        'fantasy-land/chain':       Function$prototype$chain,\n        'fantasy-land/extend':      Function$prototype$extend,\n        'fantasy-land/contramap':   Function$prototype$contramap\n      }\n    }\n  };\n  /* eslint-enable key-spacing */\n\n  //# equals :: (a, b) -> Boolean\n  //.\n  //. Returns `true` if its arguments are of the same type and equal according\n  //. to the type's [`fantasy-land/equals`][] method; `false` otherwise.\n  //.\n  //. `fantasy-land/equals` implementations are provided for the following\n  //. built-in types: Null, Undefined, Boolean, Number, Date, RegExp, String,\n  //. Array, Arguments, Error, Object, and Function.\n  //.\n  //. The algorithm supports circular data structures. Two arrays are equal\n  //. if they have the same index paths and for each path have equal values.\n  //. Two arrays which represent `[1, [1, [1, [1, [1, ...]]]]]`, for example,\n  //. are equal even if their internal structures differ. Two objects are equal\n  //. if they have the same property paths and for each path have equal values.\n  //.\n  //. ```javascript\n  //. > equals(0, -0)\n  //. true\n  //.\n  //. > equals(NaN, NaN)\n  //. true\n  //.\n  //. > equals(Cons('foo', Cons('bar', Nil)), Cons('foo', Cons('bar', Nil)))\n  //. true\n  //.\n  //. > equals(Cons('foo', Cons('bar', Nil)), Cons('bar', Cons('foo', Nil)))\n  //. false\n  //. ```\n  var equals = (function() {\n    //  $pairs :: Array (Array2 Any Any)\n    var $pairs = [];\n\n    return function equals(x, y) {\n      if (!sameType(x, y)) return false;\n\n      //  This algorithm for comparing circular data structures was\n      //  suggested in <http://stackoverflow.com/a/40622794/312785>.\n      if ($pairs.some(function(p) { return p[0] === x && p[1] === y; })) {\n        return true;\n      }\n\n      $pairs.push([x, y]);\n      try {\n        return Setoid.test(x) && Setoid.test(y) && Setoid.methods.equals(x)(y);\n      } finally {\n        $pairs.pop();\n      }\n    };\n  }());\n\n  //# lt :: (a, b) -> Boolean\n  //.\n  //. Returns `true` if its arguments are of the same type and the first is\n  //. less than the second according to the type's [`fantasy-land/lte`][]\n  //. method; `false` otherwise.\n  //.\n  //. This function is derived from [`lte`](#lte).\n  //.\n  //. See also [`gt`](#gt) and [`gte`](#gte).\n  //.\n  //. ```javascript\n  //. > lt(0, 0)\n  //. false\n  //.\n  //. > lt(0, 1)\n  //. true\n  //.\n  //. > lt(1, 0)\n  //. false\n  //. ```\n  function lt(x, y) {\n    return sameType(x, y) && !lte(y, x);\n  }\n\n  //# lte :: (a, b) -> Boolean\n  //.\n  //. Returns `true` if its arguments are of the same type and the first\n  //. is less than or equal to the second according to the type's\n  //. [`fantasy-land/lte`][] method; `false` otherwise.\n  //.\n  //. `fantasy-land/lte` implementations are provided for the following\n  //. built-in types: Null, Undefined, Boolean, Number, Date, String, Array,\n  //. Arguments, and Object.\n  //.\n  //. The algorithm supports circular data structures in the same manner as\n  //. [`equals`](#equals).\n  //.\n  //. See also [`lt`](#lt), [`gt`](#gt), and [`gte`](#gte).\n  //.\n  //. ```javascript\n  //. > lte(0, 0)\n  //. true\n  //.\n  //. > lte(0, 1)\n  //. true\n  //.\n  //. > lte(1, 0)\n  //. false\n  //. ```\n  var lte = (function() {\n    //  $pairs :: Array (Array2 Any Any)\n    var $pairs = [];\n\n    return function lte(x, y) {\n      if (!sameType(x, y)) return false;\n\n      //  This algorithm for comparing circular data structures was\n      //  suggested in <http://stackoverflow.com/a/40622794/312785>.\n      if ($pairs.some(function(p) { return p[0] === x && p[1] === y; })) {\n        return equals(x, y);\n      }\n\n      $pairs.push([x, y]);\n      try {\n        return Ord.test(x) && Ord.test(y) && Ord.methods.lte(x)(y);\n      } finally {\n        $pairs.pop();\n      }\n    };\n  }());\n\n  //# gt :: (a, b) -> Boolean\n  //.\n  //. Returns `true` if its arguments are of the same type and the first is\n  //. greater than the second according to the type's [`fantasy-land/lte`][]\n  //. method; `false` otherwise.\n  //.\n  //. This function is derived from [`lte`](#lte).\n  //.\n  //. See also [`lt`](#lt) and [`gte`](#gte).\n  //.\n  //. ```javascript\n  //. > gt(0, 0)\n  //. false\n  //.\n  //. > gt(0, 1)\n  //. false\n  //.\n  //. > gt(1, 0)\n  //. true\n  //. ```\n  function gt(x, y) {\n    return lt(y, x);\n  }\n\n  //# gte :: (a, b) -> Boolean\n  //.\n  //. Returns `true` if its arguments are of the same type and the first\n  //. is greater than or equal to the second according to the type's\n  //. [`fantasy-land/lte`][] method; `false` otherwise.\n  //.\n  //. This function is derived from [`lte`](#lte).\n  //.\n  //. See also [`lt`](#lt) and [`gt`](#gt).\n  //.\n  //. ```javascript\n  //. > gte(0, 0)\n  //. true\n  //.\n  //. > gte(0, 1)\n  //. false\n  //.\n  //. > gte(1, 0)\n  //. true\n  //. ```\n  function gte(x, y) {\n    return lte(y, x);\n  }\n\n  //# min :: Ord a => (a, a) -> a\n  //.\n  //. Returns the smaller of its two arguments.\n  //.\n  //. This function is derived from [`lte`](#lte).\n  //.\n  //. See also [`max`](#max).\n  //.\n  //. ```javascript\n  //. > min(10, 2)\n  //. 2\n  //.\n  //. > min(new Date('1999-12-31'), new Date('2000-01-01'))\n  //. new Date('1999-12-31')\n  //.\n  //. > min('10', '2')\n  //. '10'\n  //. ```\n  function min(x, y) {\n    return lte(x, y) ? x : y;\n  }\n\n  //# max :: Ord a => (a, a) -> a\n  //.\n  //. Returns the larger of its two arguments.\n  //.\n  //. This function is derived from [`lte`](#lte).\n  //.\n  //. See also [`min`](#min).\n  //.\n  //. ```javascript\n  //. > max(10, 2)\n  //. 10\n  //.\n  //. > max(new Date('1999-12-31'), new Date('2000-01-01'))\n  //. new Date('2000-01-01')\n  //.\n  //. > max('10', '2')\n  //. '2'\n  //. ```\n  function max(x, y) {\n    return lte(x, y) ? y : x;\n  }\n\n  //# compose :: Semigroupoid c => (c j k, c i j) -> c i k\n  //.\n  //. Function wrapper for [`fantasy-land/compose`][].\n  //.\n  //. `fantasy-land/compose` implementations are provided for the following\n  //. built-in types: Function.\n  //.\n  //. ```javascript\n  //. > compose(Math.sqrt, x => x + 1)(99)\n  //. 10\n  //. ```\n  function compose(x, y) {\n    return Semigroupoid.methods.compose(y)(x);\n  }\n\n  //# id :: Category c => TypeRep c -> c\n  //.\n  //. Function wrapper for [`fantasy-land/id`][].\n  //.\n  //. `fantasy-land/id` implementations are provided for the following\n  //. built-in types: Function.\n  //.\n  //. ```javascript\n  //. > id(Function)('foo')\n  //. 'foo'\n  //. ```\n  function id(typeRep) {\n    return Category.methods.id(typeRep)();\n  }\n\n  //# concat :: Semigroup a => (a, a) -> a\n  //.\n  //. Function wrapper for [`fantasy-land/concat`][].\n  //.\n  //. `fantasy-land/concat` implementations are provided for the following\n  //. built-in types: String, Array, and Object.\n  //.\n  //. ```javascript\n  //. > concat('abc', 'def')\n  //. 'abcdef'\n  //.\n  //. > concat([1, 2, 3], [4, 5, 6])\n  //. [1, 2, 3, 4, 5, 6]\n  //.\n  //. > concat({x: 1, y: 2}, {y: 3, z: 4})\n  //. {x: 1, y: 3, z: 4}\n  //.\n  //. > concat(Cons('foo', Cons('bar', Cons('baz', Nil))), Cons('quux', Nil))\n  //. Cons('foo', Cons('bar', Cons('baz', Cons('quux', Nil))))\n  //. ```\n  function concat(x, y) {\n    return Semigroup.methods.concat(x)(y);\n  }\n\n  //# empty :: Monoid m => TypeRep m -> m\n  //.\n  //. Function wrapper for [`fantasy-land/empty`][].\n  //.\n  //. `fantasy-land/empty` implementations are provided for the following\n  //. built-in types: String, Array, and Object.\n  //.\n  //. ```javascript\n  //. > empty(String)\n  //. ''\n  //.\n  //. > empty(Array)\n  //. []\n  //.\n  //. > empty(Object)\n  //. {}\n  //.\n  //. > empty(List)\n  //. Nil\n  //. ```\n  function empty(typeRep) {\n    return Monoid.methods.empty(typeRep)();\n  }\n\n  //# invert :: Group g => g -> g\n  //.\n  //. Function wrapper for [`fantasy-land/invert`][].\n  //.\n  //. ```javascript\n  //. > invert(Sum(5))\n  //. Sum(-5)\n  //. ```\n  function invert(group) {\n    return Group.methods.invert(group)();\n  }\n\n  //# filter :: Filterable f => (a -> Boolean, f a) -> f a\n  //.\n  //. Function wrapper for [`fantasy-land/filter`][]. Discards every element\n  //. which does not satisfy the predicate.\n  //.\n  //. `fantasy-land/filter` implementations are provided for the following\n  //. built-in types: Array and Object.\n  //.\n  //. See also [`reject`](#reject).\n  //.\n  //. ```javascript\n  //. > filter(x => x % 2 == 1, [1, 2, 3])\n  //. [1, 3]\n  //.\n  //. > filter(x => x % 2 == 1, {x: 1, y: 2, z: 3})\n  //. {x: 1, z: 3}\n  //.\n  //. > filter(x => x % 2 == 1, Cons(1, Cons(2, Cons(3, Nil))))\n  //. Cons(1, Cons(3, Nil))\n  //.\n  //. > filter(x => x % 2 == 1, Nothing)\n  //. Nothing\n  //.\n  //. > filter(x => x % 2 == 1, Just(0))\n  //. Nothing\n  //.\n  //. > filter(x => x % 2 == 1, Just(1))\n  //. Just(1)\n  //. ```\n  function filter(pred, filterable) {\n    return Filterable.methods.filter(filterable)(pred);\n  }\n\n  //# reject :: Filterable f => (a -> Boolean, f a) -> f a\n  //.\n  //. Discards every element which satisfies the predicate.\n  //.\n  //. This function is derived from [`filter`](#filter).\n  //.\n  //. ```javascript\n  //. > reject(x => x % 2 == 1, [1, 2, 3])\n  //. [2]\n  //.\n  //. > reject(x => x % 2 == 1, {x: 1, y: 2, z: 3})\n  //. {y: 2}\n  //.\n  //. > reject(x => x % 2 == 1, Cons(1, Cons(2, Cons(3, Nil))))\n  //. Cons(2, Nil)\n  //.\n  //. > reject(x => x % 2 == 1, Nothing)\n  //. Nothing\n  //.\n  //. > reject(x => x % 2 == 1, Just(0))\n  //. Just(0)\n  //.\n  //. > reject(x => x % 2 == 1, Just(1))\n  //. Nothing\n  //. ```\n  function reject(pred, filterable) {\n    return filter(function(x) { return !pred(x); }, filterable);\n  }\n\n  //# takeWhile :: Filterable f => (a -> Boolean, f a) -> f a\n  //.\n  //. Discards the first element which does not satisfy the predicate, and all\n  //. subsequent elements.\n  //.\n  //. This function is derived from [`filter`](#filter).\n  //.\n  //. See also [`dropWhile`](#dropWhile).\n  //.\n  //. ```javascript\n  //. > takeWhile(s => /x/.test(s), ['xy', 'xz', 'yx', 'yz', 'zx', 'zy'])\n  //. ['xy', 'xz', 'yx']\n  //.\n  //. > takeWhile(s => /y/.test(s), ['xy', 'xz', 'yx', 'yz', 'zx', 'zy'])\n  //. ['xy']\n  //.\n  //. > takeWhile(s => /z/.test(s), ['xy', 'xz', 'yx', 'yz', 'zx', 'zy'])\n  //. []\n  //. ```\n  function takeWhile(pred, filterable) {\n    var take = true;\n    return filter(function(x) { return take = take && pred(x); }, filterable);\n  }\n\n  //# dropWhile :: Filterable f => (a -> Boolean, f a) -> f a\n  //.\n  //. Retains the first element which does not satisfy the predicate, and all\n  //. subsequent elements.\n  //.\n  //. This function is derived from [`filter`](#filter).\n  //.\n  //. See also [`takeWhile`](#takeWhile).\n  //.\n  //. ```javascript\n  //. > dropWhile(s => /x/.test(s), ['xy', 'xz', 'yx', 'yz', 'zx', 'zy'])\n  //. ['yz', 'zx', 'zy']\n  //.\n  //. > dropWhile(s => /y/.test(s), ['xy', 'xz', 'yx', 'yz', 'zx', 'zy'])\n  //. ['xz', 'yx', 'yz', 'zx', 'zy']\n  //.\n  //. > dropWhile(s => /z/.test(s), ['xy', 'xz', 'yx', 'yz', 'zx', 'zy'])\n  //. ['xy', 'xz', 'yx', 'yz', 'zx', 'zy']\n  //. ```\n  function dropWhile(pred, filterable) {\n    var take = false;\n    return filter(function(x) { return take = take || !pred(x); }, filterable);\n  }\n\n  //# map :: Functor f => (a -> b, f a) -> f b\n  //.\n  //. Function wrapper for [`fantasy-land/map`][].\n  //.\n  //. `fantasy-land/map` implementations are provided for the following\n  //. built-in types: Array, Object, and Function.\n  //.\n  //. ```javascript\n  //. > map(Math.sqrt, [1, 4, 9])\n  //. [1, 2, 3]\n  //.\n  //. > map(Math.sqrt, {x: 1, y: 4, z: 9})\n  //. {x: 1, y: 2, z: 3}\n  //.\n  //. > map(Math.sqrt, s => s.length)('Sanctuary')\n  //. 3\n  //.\n  //. > map(Math.sqrt, Tuple('foo', 64))\n  //. Tuple('foo', 8)\n  //.\n  //. > map(Math.sqrt, Nil)\n  //. Nil\n  //.\n  //. > map(Math.sqrt, Cons(1, Cons(4, Cons(9, Nil))))\n  //. Cons(1, Cons(2, Cons(3, Nil)))\n  //. ```\n  function map(f, functor) {\n    return Functor.methods.map(functor)(f);\n  }\n\n  //# flip :: Functor f => (f (a -> b), a) -> f b\n  //.\n  //. Maps over the given functions, applying each to the given value.\n  //.\n  //. This function is derived from [`map`](#map).\n  //.\n  //. ```javascript\n  //. > flip(x => y => x + y, '!')('foo')\n  //. 'foo!'\n  //.\n  //. > flip([Math.floor, Math.ceil], 1.5)\n  //. [1, 2]\n  //.\n  //. > flip({floor: Math.floor, ceil: Math.ceil}, 1.5)\n  //. {floor: 1, ceil: 2}\n  //.\n  //. > flip(Cons(Math.floor, Cons(Math.ceil, Nil)), 1.5)\n  //. Cons(1, Cons(2, Nil))\n  //. ```\n  function flip(functor, x) {\n    return Functor.methods.map(functor)(thrush(x));\n  }\n\n  //# bimap :: Bifunctor f => (a -> b, c -> d, f a c) -> f b d\n  //.\n  //. Function wrapper for [`fantasy-land/bimap`][].\n  //.\n  //. ```javascript\n  //. > bimap(s => s.toUpperCase(), Math.sqrt, Tuple('foo', 64))\n  //. Tuple('FOO', 8)\n  //. ```\n  function bimap(f, g, bifunctor) {\n    return Bifunctor.methods.bimap(bifunctor)(f, g);\n  }\n\n  //# mapLeft :: Bifunctor f => (a -> b, f a c) -> f b c\n  //.\n  //. Maps the given function over the left side of a Bifunctor.\n  //.\n  //. ```javascript\n  //. > mapLeft(Math.sqrt, Tuple(64, 9))\n  //. Tuple(8, 9)\n  //. ```\n  function mapLeft(f, bifunctor) {\n    return bimap(f, identity, bifunctor);\n  }\n\n  //# promap :: Profunctor p => (a -> b, c -> d, p b c) -> p a d\n  //.\n  //. Function wrapper for [`fantasy-land/promap`][].\n  //.\n  //. `fantasy-land/promap` implementations are provided for the following\n  //. built-in types: Function.\n  //.\n  //. ```javascript\n  //. > promap(Math.abs, x => x + 1, Math.sqrt)(-100)\n  //. 11\n  //. ```\n  function promap(f, g, profunctor) {\n    return Profunctor.methods.promap(profunctor)(f, g);\n  }\n\n  //# ap :: Apply f => (f (a -> b), f a) -> f b\n  //.\n  //. Function wrapper for [`fantasy-land/ap`][].\n  //.\n  //. `fantasy-land/ap` implementations are provided for the following\n  //. built-in types: Array, Object, and Function.\n  //.\n  //. ```javascript\n  //. > ap([Math.sqrt, x => x * x], [1, 4, 9, 16, 25])\n  //. [1, 2, 3, 4, 5, 1, 16, 81, 256, 625]\n  //.\n  //. > ap({a: Math.sqrt, b: x => x * x}, {a: 16, b: 10, c: 1})\n  //. {a: 4, b: 100}\n  //.\n  //. > ap(s => n => s.slice(0, n), s => Math.ceil(s.length / 2))('Haskell')\n  //. 'Hask'\n  //.\n  //. > ap(Identity(Math.sqrt), Identity(64))\n  //. Identity(8)\n  //.\n  //. > ap(Cons(Math.sqrt, Cons(x => x * x, Nil)), Cons(16, Cons(100, Nil)))\n  //. Cons(4, Cons(10, Cons(256, Cons(10000, Nil))))\n  //. ```\n  function ap(applyF, applyX) {\n    return Apply.methods.ap(applyX)(applyF);\n  }\n\n  //# lift2 :: Apply f => (a -> b -> c, f a, f b) -> f c\n  //.\n  //. Lifts `a -> b -> c` to `Apply f => f a -> f b -> f c` and returns the\n  //. result of applying this to the given arguments.\n  //.\n  //. This function is derived from [`map`](#map) and [`ap`](#ap).\n  //.\n  //. See also [`lift3`](#lift3).\n  //.\n  //. ```javascript\n  //. > lift2(x => y => Math.pow(x, y), [10], [1, 2, 3])\n  //. [10, 100, 1000]\n  //.\n  //. > lift2(x => y => Math.pow(x, y), Identity(10), Identity(3))\n  //. Identity(1000)\n  //. ```\n  function lift2(f, x, y) {\n    return ap(map(f, x), y);\n  }\n\n  //# lift3 :: Apply f => (a -> b -> c -> d, f a, f b, f c) -> f d\n  //.\n  //. Lifts `a -> b -> c -> d` to `Apply f => f a -> f b -> f c -> f d` and\n  //. returns the result of applying this to the given arguments.\n  //.\n  //. This function is derived from [`map`](#map) and [`ap`](#ap).\n  //.\n  //. See also [`lift2`](#lift2).\n  //.\n  //. ```javascript\n  //. > lift3(x => y => z => x + z + y, ['<'], ['>'], ['foo', 'bar', 'baz'])\n  //. ['<foo>', '<bar>', '<baz>']\n  //.\n  //. > lift3(x => y => z => x + z + y, Identity('<'), Identity('>'), Identity('baz'))\n  //. Identity('<baz>')\n  //. ```\n  function lift3(f, x, y, z) {\n    return ap(ap(map(f, x), y), z);\n  }\n\n  //# apFirst :: Apply f => (f a, f b) -> f a\n  //.\n  //. Combines two effectful actions, keeping only the result of the first.\n  //. Equivalent to Haskell's `(<*)` function.\n  //.\n  //. This function is derived from [`lift2`](#lift2).\n  //.\n  //. See also [`apSecond`](#apSecond).\n  //.\n  //. ```javascript\n  //. > apFirst([1, 2], [3, 4])\n  //. [1, 1, 2, 2]\n  //.\n  //. > apFirst(Identity(1), Identity(2))\n  //. Identity(1)\n  //. ```\n  function apFirst(x, y) {\n    return lift2(constant, x, y);\n  }\n\n  //# apSecond :: Apply f => (f a, f b) -> f b\n  //.\n  //. Combines two effectful actions, keeping only the result of the second.\n  //. Equivalent to Haskell's `(*>)` function.\n  //.\n  //. This function is derived from [`lift2`](#lift2).\n  //.\n  //. See also [`apFirst`](#apFirst).\n  //.\n  //. ```javascript\n  //. > apSecond([1, 2], [3, 4])\n  //. [3, 4, 3, 4]\n  //.\n  //. > apSecond(Identity(1), Identity(2))\n  //. Identity(2)\n  //. ```\n  function apSecond(x, y) {\n    return lift2(constant(identity), x, y);\n  }\n\n  //# of :: Applicative f => (TypeRep f, a) -> f a\n  //.\n  //. Function wrapper for [`fantasy-land/of`][].\n  //.\n  //. `fantasy-land/of` implementations are provided for the following\n  //. built-in types: Array and Function.\n  //.\n  //. ```javascript\n  //. > of(Array, 42)\n  //. [42]\n  //.\n  //. > of(Function, 42)(null)\n  //. 42\n  //.\n  //. > of(List, 42)\n  //. Cons(42, Nil)\n  //. ```\n  function of(typeRep, x) {\n    return Applicative.methods.of(typeRep)(x);\n  }\n\n  //# append :: (Applicative f, Semigroup (f a)) => (a, f a) -> f a\n  //.\n  //. Returns the result of appending the first argument to the second.\n  //.\n  //. This function is derived from [`concat`](#concat) and [`of`](#of).\n  //.\n  //. See also [`prepend`](#prepend).\n  //.\n  //. ```javascript\n  //. > append(3, [1, 2])\n  //. [1, 2, 3]\n  //.\n  //. > append(3, Cons(1, Cons(2, Nil)))\n  //. Cons(1, Cons(2, Cons(3, Nil)))\n  //. ```\n  function append(x, xs) {\n    return concat(xs, of(xs.constructor, x));\n  }\n\n  //# prepend :: (Applicative f, Semigroup (f a)) => (a, f a) -> f a\n  //.\n  //. Returns the result of prepending the first argument to the second.\n  //.\n  //. This function is derived from [`concat`](#concat) and [`of`](#of).\n  //.\n  //. See also [`append`](#append).\n  //.\n  //. ```javascript\n  //. > prepend(1, [2, 3])\n  //. [1, 2, 3]\n  //.\n  //. > prepend(1, Cons(2, Cons(3, Nil)))\n  //. Cons(1, Cons(2, Cons(3, Nil)))\n  //. ```\n  function prepend(x, xs) {\n    return concat(of(xs.constructor, x), xs);\n  }\n\n  //# chain :: Chain m => (a -> m b, m a) -> m b\n  //.\n  //. Function wrapper for [`fantasy-land/chain`][].\n  //.\n  //. `fantasy-land/chain` implementations are provided for the following\n  //. built-in types: Array and Function.\n  //.\n  //. ```javascript\n  //. > chain(x => [x, x], [1, 2, 3])\n  //. [1, 1, 2, 2, 3, 3]\n  //.\n  //. > chain(x => x % 2 == 1 ? of(List, x) : Nil, Cons(1, Cons(2, Cons(3, Nil))))\n  //. Cons(1, Cons(3, Nil))\n  //.\n  //. > chain(n => s => s.slice(0, n), s => Math.ceil(s.length / 2))('Haskell')\n  //. 'Hask'\n  //. ```\n  function chain(f, chain_) {\n    return Chain.methods.chain(chain_)(f);\n  }\n\n  //# join :: Chain m => m (m a) -> m a\n  //.\n  //. Removes one level of nesting from a nested monadic structure.\n  //.\n  //. This function is derived from [`chain`](#chain).\n  //.\n  //. ```javascript\n  //. > join([[1], [2], [3]])\n  //. [1, 2, 3]\n  //.\n  //. > join([[[1, 2, 3]]])\n  //. [[1, 2, 3]]\n  //.\n  //. > join(Identity(Identity(1)))\n  //. Identity(1)\n  //. ```\n  function join(chain_) {\n    return chain(identity, chain_);\n  }\n\n  //# chainRec :: ChainRec m => (TypeRep m, (a -> c, b -> c, a) -> m c, a) -> m b\n  //.\n  //. Function wrapper for [`fantasy-land/chainRec`][].\n  //.\n  //. `fantasy-land/chainRec` implementations are provided for the following\n  //. built-in types: Array.\n  //.\n  //. ```javascript\n  //. > chainRec(\n  //. .   Array,\n  //. .   (next, done, s) => s.length == 2 ? [s + '!', s + '?'].map(done)\n  //. .                                    : [s + 'o', s + 'n'].map(next),\n  //. .   ''\n  //. . )\n  //. ['oo!', 'oo?', 'on!', 'on?', 'no!', 'no?', 'nn!', 'nn?']\n  //. ```\n  function chainRec(typeRep, f, x) {\n    return ChainRec.methods.chainRec(typeRep)(f, x);\n  }\n\n  //# alt :: Alt f => (f a, f a) -> f a\n  //.\n  //. Function wrapper for [`fantasy-land/alt`][].\n  //.\n  //. `fantasy-land/alt` implementations are provided for the following\n  //. built-in types: Array and Object.\n  //.\n  //. ```javascript\n  //. > alt([1, 2, 3], [4, 5, 6])\n  //. [1, 2, 3, 4, 5, 6]\n  //.\n  //. > alt(Nothing, Nothing)\n  //. Nothing\n  //.\n  //. > alt(Nothing, Just(1))\n  //. Just(1)\n  //.\n  //. > alt(Just(2), Just(3))\n  //. Just(2)\n  //. ```\n  function alt(x, y) {\n    return Alt.methods.alt(x)(y);\n  }\n\n  //# zero :: Plus f => TypeRep f -> f a\n  //.\n  //. Function wrapper for [`fantasy-land/zero`][].\n  //.\n  //. `fantasy-land/zero` implementations are provided for the following\n  //. built-in types: Array and Object.\n  //.\n  //. ```javascript\n  //. > zero(Array)\n  //. []\n  //.\n  //. > zero(Object)\n  //. {}\n  //.\n  //. > zero(Maybe)\n  //. Nothing\n  //. ```\n  function zero(typeRep) {\n    return Plus.methods.zero(typeRep)();\n  }\n\n  //# reduce :: Foldable f => ((b, a) -> b, b, f a) -> b\n  //.\n  //. Function wrapper for [`fantasy-land/reduce`][].\n  //.\n  //. `fantasy-land/reduce` implementations are provided for the following\n  //. built-in types: Array and Object.\n  //.\n  //. ```javascript\n  //. > reduce((xs, x) => [x].concat(xs), [], [1, 2, 3])\n  //. [3, 2, 1]\n  //.\n  //. > reduce(concat, '', Cons('foo', Cons('bar', Cons('baz', Nil))))\n  //. 'foobarbaz'\n  //. ```\n  function reduce(f, x, foldable) {\n    return Foldable.methods.reduce(foldable)(f, x);\n  }\n\n  //# size :: Foldable f => f a -> Integer\n  //.\n  //. Returns the number of elements of the given structure.\n  //.\n  //. This function is derived from [`reduce`](#reduce).\n  //.\n  //. ```javascript\n  //. > size([])\n  //. 0\n  //.\n  //. > size(['foo', 'bar', 'baz'])\n  //. 3\n  //.\n  //. > size(Nil)\n  //. 0\n  //.\n  //. > size(Cons('foo', Cons('bar', Cons('baz', Nil))))\n  //. 3\n  //. ```\n  function size(foldable) {\n    //  Fast path for arrays.\n    if (Array.isArray(foldable)) return foldable.length;\n    return reduce(function(n, _) { return n + 1; }, 0, foldable);\n  }\n\n  //# elem :: (Setoid a, Foldable f) => (a, f a) -> Boolean\n  //.\n  //. Takes a value and a structure and returns `true` if the\n  //. value is an element of the structure; `false` otherwise.\n  //.\n  //. This function is derived from [`equals`](#equals) and\n  //. [`reduce`](#reduce).\n  //.\n  //. ```javascript\n  //. > elem('c', ['a', 'b', 'c'])\n  //. true\n  //.\n  //. > elem('x', ['a', 'b', 'c'])\n  //. false\n  //.\n  //. > elem(3, {x: 1, y: 2, z: 3})\n  //. true\n  //.\n  //. > elem(8, {x: 1, y: 2, z: 3})\n  //. false\n  //.\n  //. > elem(0, Just(0))\n  //. true\n  //.\n  //. > elem(0, Just(1))\n  //. false\n  //.\n  //. > elem(0, Nothing)\n  //. false\n  //. ```\n  function elem(x, foldable) {\n    return reduce(function(b, y) { return b || equals(x, y); },\n                  false,\n                  foldable);\n  }\n\n  //# foldMap :: (Monoid m, Foldable f) => (TypeRep m, a -> m, f a) -> m\n  //.\n  //. Deconstructs a foldable by mapping every element to a monoid and\n  //. concatenating the results.\n  //.\n  //. This function is derived from [`concat`](#concat), [`empty`](#empty),\n  //. and [`reduce`](#reduce).\n  //.\n  //. ```javascript\n  //. > foldMap(String, f => f.name, [Math.sin, Math.cos, Math.tan])\n  //. 'sincostan'\n  //. ```\n  function foldMap(typeRep, f, foldable) {\n    return reduce(function(monoid, x) { return concat(monoid, f(x)); },\n                  empty(typeRep),\n                  foldable);\n  }\n\n  //# reverse :: (Applicative f, Foldable f, Monoid (f a)) => f a -> f a\n  //.\n  //. Reverses the elements of the given structure.\n  //.\n  //. This function is derived from [`concat`](#concat), [`empty`](#empty),\n  //. [`of`](#of), and [`reduce`](#reduce).\n  //.\n  //. ```javascript\n  //. > reverse([1, 2, 3])\n  //. [3, 2, 1]\n  //.\n  //. > reverse(Cons(1, Cons(2, Cons(3, Nil))))\n  //. Cons(3, Cons(2, Cons(1, Nil)))\n  //. ```\n  function reverse(foldable) {\n    //  Fast path for arrays.\n    if (Array.isArray(foldable)) return foldable.slice().reverse();\n    var F = foldable.constructor;\n    return reduce(function(xs, x) { return concat(of(F, x), xs); },\n                  empty(F),\n                  foldable);\n  }\n\n  //# sort :: (Ord a, Applicative f, Foldable f, Monoid (f a)) => f a -> f a\n  //.\n  //. Performs a [stable sort][] of the elements of the given structure,\n  //. using [`lte`](#lte) for comparisons.\n  //.\n  //. This function is derived from [`lte`](#lte), [`concat`](#concat),\n  //. [`empty`](#empty), [`of`](#of), and [`reduce`](#reduce).\n  //.\n  //. See also [`sortBy`](#sortBy).\n  //.\n  //. ```javascript\n  //. > sort(['foo', 'bar', 'baz'])\n  //. ['bar', 'baz', 'foo']\n  //.\n  //. > sort([Just(2), Nothing, Just(1)])\n  //. [Nothing, Just(1), Just(2)]\n  //.\n  //. > sort(Cons('foo', Cons('bar', Cons('baz', Nil))))\n  //. Cons('bar', Cons('baz', Cons('foo', Nil)))\n  //. ```\n  function sort(foldable) {\n    return sortBy(identity, foldable);\n  }\n\n  //# sortBy :: (Ord b, Applicative f, Foldable f, Monoid (f a)) => (a -> b, f a) -> f a\n  //.\n  //. Performs a [stable sort][] of the elements of the given structure,\n  //. using [`lte`](#lte) to compare the values produced by applying the\n  //. given function to each element of the structure.\n  //.\n  //. This function is derived from [`lte`](#lte), [`concat`](#concat),\n  //. [`empty`](#empty), [`of`](#of), and [`reduce`](#reduce).\n  //.\n  //. See also [`sort`](#sort).\n  //.\n  //. ```javascript\n  //. > sortBy(s => s.length, ['red', 'green', 'blue'])\n  //. ['red', 'blue', 'green']\n  //.\n  //. > sortBy(s => s.length, ['black', 'white'])\n  //. ['black', 'white']\n  //.\n  //. > sortBy(s => s.length, ['white', 'black'])\n  //. ['white', 'black']\n  //.\n  //. > sortBy(s => s.length, Cons('red', Cons('green', Cons('blue', Nil))))\n  //. Cons('red', Cons('blue', Cons('green', Nil)))\n  //. ```\n  function sortBy(f, foldable) {\n    var rs = reduce(function(rs, x) {\n      rs.push({idx: rs.length, x: x, fx: f(x)});\n      return rs;\n    }, [], foldable);\n\n    var lte_ = (function(r) {\n      switch (typeof (r && r.fx)) {\n        case 'number':  return function(x, y) { return x <= y || x !== x; };\n        case 'string':  return function(x, y) { return x <= y; };\n        default:        return lte;\n      }\n    }(rs[0]));\n\n    rs.sort(function(a, b) {\n      return lte_(a.fx, b.fx) ? lte_(b.fx, a.fx) ? a.idx - b.idx : -1 : 1;\n    });\n\n    if (Array.isArray(foldable)) {\n      for (var idx = 0; idx < rs.length; idx += 1) rs[idx] = rs[idx].x;\n      return rs;\n    }\n\n    var F = foldable.constructor;\n    var result = empty(F);\n    for (idx = 0; idx < rs.length; idx += 1) {\n      result = concat(result, of(F, rs[idx].x));\n    }\n    return result;\n  }\n\n  //# traverse :: (Applicative f, Traversable t) => (TypeRep f, a -> f b, t a) -> f (t b)\n  //.\n  //. Function wrapper for [`fantasy-land/traverse`][].\n  //.\n  //. `fantasy-land/traverse` implementations are provided for the following\n  //. built-in types: Array and Object.\n  //.\n  //. See also [`sequence`](#sequence).\n  //.\n  //. ```javascript\n  //. > traverse(Array, x => x, [[1, 2, 3], [4, 5]])\n  //. [[1, 4], [1, 5], [2, 4], [2, 5], [3, 4], [3, 5]]\n  //.\n  //. > traverse(Identity, x => Identity(x + 1), [1, 2, 3])\n  //. Identity([2, 3, 4])\n  //. ```\n  function traverse(typeRep, f, traversable) {\n    return Traversable.methods.traverse(traversable)(typeRep, f);\n  }\n\n  //# sequence :: (Applicative f, Traversable t) => (TypeRep f, t (f a)) -> f (t a)\n  //.\n  //. Inverts the given `t (f a)` to produce an `f (t a)`.\n  //.\n  //. This function is derived from [`traverse`](#traverse).\n  //.\n  //. ```javascript\n  //. > sequence(Array, Identity([1, 2, 3]))\n  //. [Identity(1), Identity(2), Identity(3)]\n  //.\n  //. > sequence(Identity, [Identity(1), Identity(2), Identity(3)])\n  //. Identity([1, 2, 3])\n  //. ```\n  function sequence(typeRep, traversable) {\n    return traverse(typeRep, identity, traversable);\n  }\n\n  //# extend :: Extend w => (w a -> b, w a) -> w b\n  //.\n  //. Function wrapper for [`fantasy-land/extend`][].\n  //.\n  //. `fantasy-land/extend` implementations are provided for the following\n  //. built-in types: Array and Function.\n  //.\n  //. ```javascript\n  //. > extend(ss => ss.join(''), ['x', 'y', 'z'])\n  //. ['xyz', 'yz', 'z']\n  //.\n  //. > extend(f => f([3, 4]), reverse)([1, 2])\n  //. [4, 3, 2, 1]\n  //. ```\n  function extend(f, extend_) {\n    return Extend.methods.extend(extend_)(f);\n  }\n\n  //# duplicate :: Extend w => w a -> w (w a)\n  //.\n  //. Adds one level of nesting to a comonadic structure.\n  //.\n  //. This function is derived from [`extend`](#extend).\n  //.\n  //. ```javascript\n  //. > duplicate(Identity(1))\n  //. Identity(Identity(1))\n  //.\n  //. > duplicate([1])\n  //. [[1]]\n  //.\n  //. > duplicate([1, 2, 3])\n  //. [[1, 2, 3], [2, 3], [3]]\n  //.\n  //. > duplicate(reverse)([1, 2])([3, 4])\n  //. [4, 3, 2, 1]\n  //. ```\n  function duplicate(extend_) {\n    return extend(identity, extend_);\n  }\n\n  //# extract :: Comonad w => w a -> a\n  //.\n  //. Function wrapper for [`fantasy-land/extract`][].\n  //.\n  //. ```javascript\n  //. > extract(Identity(42))\n  //. 42\n  //. ```\n  function extract(comonad) {\n    return Comonad.methods.extract(comonad)();\n  }\n\n  //# contramap :: Contravariant f => (b -> a, f a) -> f b\n  //.\n  //. Function wrapper for [`fantasy-land/contramap`][].\n  //.\n  //. `fantasy-land/contramap` implementations are provided for the following\n  //. built-in types: Function.\n  //.\n  //. ```javascript\n  //. > contramap(s => s.length, Math.sqrt)('Sanctuary')\n  //. 3\n  //. ```\n  function contramap(f, contravariant) {\n    return Contravariant.methods.contramap(contravariant)(f);\n  }\n\n  return {\n    TypeClass: TypeClass,\n    Setoid: Setoid,\n    Ord: Ord,\n    Semigroupoid: Semigroupoid,\n    Category: Category,\n    Semigroup: Semigroup,\n    Monoid: Monoid,\n    Group: Group,\n    Filterable: Filterable,\n    Functor: Functor,\n    Bifunctor: Bifunctor,\n    Profunctor: Profunctor,\n    Apply: Apply,\n    Applicative: Applicative,\n    Chain: Chain,\n    ChainRec: ChainRec,\n    Monad: Monad,\n    Alt: Alt,\n    Plus: Plus,\n    Alternative: Alternative,\n    Foldable: Foldable,\n    Traversable: Traversable,\n    Extend: Extend,\n    Comonad: Comonad,\n    Contravariant: Contravariant,\n    equals: equals,\n    lt: lt,\n    lte: lte,\n    gt: gt,\n    gte: gte,\n    min: min,\n    max: max,\n    compose: compose,\n    id: id,\n    concat: concat,\n    empty: empty,\n    invert: invert,\n    filter: filter,\n    reject: reject,\n    map: map,\n    flip: flip,\n    bimap: bimap,\n    mapLeft: mapLeft,\n    promap: promap,\n    ap: ap,\n    lift2: lift2,\n    lift3: lift3,\n    apFirst: apFirst,\n    apSecond: apSecond,\n    of: of,\n    append: append,\n    prepend: prepend,\n    chain: chain,\n    join: join,\n    chainRec: chainRec,\n    alt: alt,\n    zero: zero,\n    reduce: reduce,\n    size: size,\n    elem: elem,\n    foldMap: foldMap,\n    reverse: reverse,\n    sort: sort,\n    sortBy: sortBy,\n    takeWhile: takeWhile,\n    dropWhile: dropWhile,\n    traverse: traverse,\n    sequence: sequence,\n    extend: extend,\n    duplicate: duplicate,\n    extract: extract,\n    contramap: contramap\n  };\n\n}));\n\n//. [Alt]:                      v:fantasyland/fantasy-land#alt\n//. [Alternative]:              v:fantasyland/fantasy-land#alternative\n//. [Applicative]:              v:fantasyland/fantasy-land#applicative\n//. [Apply]:                    v:fantasyland/fantasy-land#apply\n//. [Bifunctor]:                v:fantasyland/fantasy-land#bifunctor\n//. [Category]:                 v:fantasyland/fantasy-land#category\n//. [Chain]:                    v:fantasyland/fantasy-land#chain\n//. [ChainRec]:                 v:fantasyland/fantasy-land#chainrec\n//. [Comonad]:                  v:fantasyland/fantasy-land#comonad\n//. [Contravariant]:            v:fantasyland/fantasy-land#contravariant\n//. [Extend]:                   v:fantasyland/fantasy-land#extend\n//. [FL]:                       v:fantasyland/fantasy-land\n//. [Filterable]:               v:fantasyland/fantasy-land#filterable\n//. [Foldable]:                 v:fantasyland/fantasy-land#foldable\n//. [Functor]:                  v:fantasyland/fantasy-land#functor\n//. [Group]:                    v:fantasyland/fantasy-land#group\n//. [Monad]:                    v:fantasyland/fantasy-land#monad\n//. [Monoid]:                   v:fantasyland/fantasy-land#monoid\n//. [Ord]:                      v:fantasyland/fantasy-land#ord\n//. [Plus]:                     v:fantasyland/fantasy-land#plus\n//. [Profunctor]:               v:fantasyland/fantasy-land#profunctor\n//. [Semigroup]:                v:fantasyland/fantasy-land#semigroup\n//. [Semigroupoid]:             v:fantasyland/fantasy-land#semigroupoid\n//. [Setoid]:                   v:fantasyland/fantasy-land#setoid\n//. [Traversable]:              v:fantasyland/fantasy-land#traversable\n//. [`fantasy-land/alt`]:       v:fantasyland/fantasy-land#alt-method\n//. [`fantasy-land/ap`]:        v:fantasyland/fantasy-land#ap-method\n//. [`fantasy-land/bimap`]:     v:fantasyland/fantasy-land#bimap-method\n//. [`fantasy-land/chain`]:     v:fantasyland/fantasy-land#chain-method\n//. [`fantasy-land/chainRec`]:  v:fantasyland/fantasy-land#chainrec-method\n//. [`fantasy-land/compose`]:   v:fantasyland/fantasy-land#compose-method\n//. [`fantasy-land/concat`]:    v:fantasyland/fantasy-land#concat-method\n//. [`fantasy-land/contramap`]: v:fantasyland/fantasy-land#contramap-method\n//. [`fantasy-land/empty`]:     v:fantasyland/fantasy-land#empty-method\n//. [`fantasy-land/equals`]:    v:fantasyland/fantasy-land#equals-method\n//. [`fantasy-land/extend`]:    v:fantasyland/fantasy-land#extend-method\n//. [`fantasy-land/extract`]:   v:fantasyland/fantasy-land#extract-method\n//. [`fantasy-land/filter`]:    v:fantasyland/fantasy-land#filter-method\n//. [`fantasy-land/id`]:        v:fantasyland/fantasy-land#id-method\n//. [`fantasy-land/invert`]:    v:fantasyland/fantasy-land#invert-method\n//. [`fantasy-land/lte`]:       v:fantasyland/fantasy-land#lte-method\n//. [`fantasy-land/map`]:       v:fantasyland/fantasy-land#map-method\n//. [`fantasy-land/of`]:        v:fantasyland/fantasy-land#of-method\n//. [`fantasy-land/promap`]:    v:fantasyland/fantasy-land#promap-method\n//. [`fantasy-land/reduce`]:    v:fantasyland/fantasy-land#reduce-method\n//. [`fantasy-land/traverse`]:  v:fantasyland/fantasy-land#traverse-method\n//. [`fantasy-land/zero`]:      v:fantasyland/fantasy-land#zero-method\n//. [stable sort]:              https://en.wikipedia.org/wiki/Sorting_algorithm#Stability\n//. [type-classes]:             https://github.com/sanctuary-js/sanctuary-def#type-classes\n", "import {Vertex} from './Vertex';\r\nimport * as Collections from 'typescript-collections';\r\n\r\nexport class Entry\r\n{\r\n  constructor(rank: Vertex, action: () => void)\r\n  {\r\n    this.rank = rank;\r\n    this.action = action;\r\n    this.seq = Entry.nextSeq++;\r\n  }\r\n\r\n  private static nextSeq: number = 0;\r\n  rank: Vertex;\r\n  action: () => void;\r\n  seq: number;\r\n\r\n  toString(): string\r\n  {\r\n    return this.seq.toString();\r\n  }\r\n}\r\n\r\nexport class Transaction\r\n{\r\n  public static currentTransaction: Transaction = null;\r\n  private static onStartHooks: (() => void)[] = [];\r\n  private static runningOnStartHooks: boolean = false;\r\n\r\n  constructor() {}\r\n\r\n  inCallback: number = 0;\r\n  private toRegen: boolean = false;\r\n\r\n  requestRegen(): void\r\n  {\r\n    this.toRegen = true;\r\n  }\r\n\r\n  prioritizedQ: Collections.PriorityQueue<Entry> = new Collections.PriorityQueue<Entry>((a, b) =>\r\n  {\r\n    // Note: Low priority numbers are treated as \"greater\" according to this\r\n    // comparison, so that the lowest numbers are highest priority and go first.\r\n    if (a.rank.rank < b.rank.rank) return 1;\r\n    if (a.rank.rank > b.rank.rank) return -1;\r\n    if (a.seq < b.seq) return 1;\r\n    if (a.seq > b.seq) return -1;\r\n    return 0;\r\n  });\r\n  private entries: Collections.Set<Entry> = new Collections.Set<Entry>((a) => a.toString());\r\n  private sampleQ: Array<() => void> = [];\r\n  private lastQ: Array<() => void> = [];\r\n  private postQ: Array<() => void> = null;\r\n  private static collectCyclesAtEnd: boolean = false;\r\n\r\n  prioritized(target: Vertex, action: () => void): void\r\n  {\r\n    const e = new Entry(target, action);\r\n    this.prioritizedQ.enqueue(e);\r\n    this.entries.add(e);\r\n  }\r\n\r\n  sample(h: () => void): void\r\n  {\r\n    this.sampleQ.push(h);\r\n  }\r\n\r\n  last(h: () => void): void\r\n  {\r\n    this.lastQ.push(h);\r\n  }\r\n\r\n  public static _collectCyclesAtEnd(): void\r\n  {\r\n    Transaction.run(() => Transaction.collectCyclesAtEnd = true);\r\n  }\r\n\r\n  /**\r\n   * Add an action to run after all last() actions.\r\n   */\r\n  post(childIx: number, action: () => void): void\r\n  {\r\n    if (this.postQ == null)\r\n      this.postQ = [];\r\n    // If an entry exists already, combine the old one with the new one.\r\n    while (this.postQ.length <= childIx)\r\n      this.postQ.push(null);\r\n    const existing = this.postQ[childIx],\r\n      neu =\r\n        existing === null ? action\r\n          : () =>\r\n        {\r\n          existing();\r\n          action();\r\n        };\r\n    this.postQ[childIx] = neu;\r\n  }\r\n\r\n  // If the priority queue has entries in it when we modify any of the nodes'\r\n  // ranks, then we need to re-generate it to make sure it's up-to-date.\r\n  private checkRegen(): void\r\n  {\r\n    if (this.toRegen)\r\n    {\r\n      this.toRegen = false;\r\n      this.prioritizedQ.clear();\r\n      const es = this.entries.toArray();\r\n      for (let i: number = 0; i < es.length; i++)\r\n        this.prioritizedQ.enqueue(es[i]);\r\n    }\r\n  }\r\n\r\n  public isActive() : boolean\r\n  {\r\n    return Transaction.currentTransaction ? true : false;\r\n  }\r\n\r\n  close(): void\r\n  {\r\n    while(true)\r\n    {\r\n      while (true)\r\n      {\r\n        this.checkRegen();\r\n        if (this.prioritizedQ.isEmpty()) break;\r\n        const e = this.prioritizedQ.dequeue();\r\n        this.entries.remove(e);\r\n        e.action();\r\n      }\r\n\r\n      const sq = this.sampleQ;\r\n      this.sampleQ = [];\r\n      for (let i = 0; i < sq.length; i++)\r\n        sq[i]();\r\n\r\n      if(this.prioritizedQ.isEmpty() && this.sampleQ.length < 1) break;\r\n    }\r\n\r\n    for (let i = 0; i < this.lastQ.length; i++)\r\n      this.lastQ[i]();\r\n    this.lastQ = [];\r\n    if (this.postQ != null)\r\n    {\r\n      for (let i = 0; i < this.postQ.length; i++)\r\n      {\r\n        if (this.postQ[i] != null)\r\n        {\r\n          const parent = Transaction.currentTransaction;\r\n          try\r\n          {\r\n            if (i > 0)\r\n            {\r\n              Transaction.currentTransaction = new Transaction();\r\n              try\r\n              {\r\n                this.postQ[i]();\r\n                Transaction.currentTransaction.close();\r\n              }\r\n              catch (err)\r\n              {\r\n                Transaction.currentTransaction.close();\r\n                throw err;\r\n              }\r\n            }\r\n            else\r\n            {\r\n              Transaction.currentTransaction = null;\r\n              this.postQ[i]();\r\n            }\r\n            Transaction.currentTransaction = parent;\r\n          }\r\n          catch (err)\r\n          {\r\n            Transaction.currentTransaction = parent;\r\n            throw err;\r\n          }\r\n        }\r\n      }\r\n      this.postQ = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add a runnable that will be executed whenever a transaction is started.\r\n   * That runnable may start transactions itself, which will not cause the\r\n   * hooks to be run recursively.\r\n   *\r\n   * The main use case of this is the implementation of a time/alarm system.\r\n   */\r\n  static onStart(r: () => void): void\r\n  {\r\n    Transaction.onStartHooks.push(r);\r\n  }\r\n\r\n  public static run<A>(f: () => A): A\r\n  {\r\n    const transWas: Transaction = Transaction.currentTransaction;\r\n    if (transWas === null)\r\n    {\r\n      if (!Transaction.runningOnStartHooks)\r\n      {\r\n        Transaction.runningOnStartHooks = true;\r\n        try\r\n        {\r\n          for (let i = 0; i < Transaction.onStartHooks.length; i++)\r\n            Transaction.onStartHooks[i]();\r\n        }\r\n        finally\r\n        {\r\n          Transaction.runningOnStartHooks = false;\r\n        }\r\n      }\r\n      Transaction.currentTransaction = new Transaction();\r\n    }\r\n    try\r\n    {\r\n      const a: A = f();\r\n      if (transWas === null)\r\n      {\r\n        Transaction.currentTransaction.close();\r\n        Transaction.currentTransaction = null;\r\n        if (Transaction.collectCyclesAtEnd) {\r\n          Vertex.collectCycles();\r\n          Transaction.collectCyclesAtEnd = false;\r\n        }\r\n      }\r\n      return a;\r\n    }\r\n    catch (err)\r\n    {\r\n      if (transWas === null)\r\n      {\r\n        Transaction.currentTransaction.close();\r\n        Transaction.currentTransaction = null;\r\n      }\r\n      throw err;\r\n    }\r\n  }\r\n}\r\n\r\n\r\n", "import { Transaction } from \"./Transaction\";\r\nimport { Set } from \"typescript-collections\";\r\n\r\nlet totalRegistrations : number = 0;\r\nexport function getTotalRegistrations() : number {\r\n    return totalRegistrations;\r\n}\r\n\r\nexport class Source {\r\n    // Note:\r\n    // When register_ == null, a rank-independent source is constructed (a vertex which is just kept alive for the\r\n    // lifetime of vertex that contains this source).\r\n    // When register_ != null it is likely to be a rank-dependent source, but this will depend on the code inside register_.\r\n    //\r\n    // rank-independent souces DO NOT bump up the rank of the vertex containing those sources.\r\n    // rank-depdendent sources DO bump up the rank of the vertex containing thoses sources when required.\r\n    constructor(\r\n        origin : Vertex,\r\n        register_ : () => () => void\r\n    ) {\r\n        if (origin === null)\r\n            throw new Error(\"null origin!\");\r\n        this.origin = origin;\r\n        this.register_ = register_;\r\n    }\r\n    origin : Vertex;\r\n    private register_ : () => () => void;\r\n    private registered : boolean = false;\r\n    private deregister_ : () => void = null;\r\n\r\n    register(target : Vertex) : void {\r\n        if (!this.registered) {\r\n            this.registered = true;\r\n            if (this.register_ !== null)\r\n                this.deregister_ = this.register_();\r\n            else {\r\n                // Note: The use of Vertex.NULL here instead of \"target\" is not a bug, this is done to create a\r\n                // rank-independent source. (see note at constructor for more details.). The origin vertex still gets\r\n                // added target vertex's children for the memory management algorithm.\r\n                this.origin.increment(Vertex.NULL);\r\n                target.childrn.push(this.origin);\r\n                this.deregister_ = () => {\r\n                    this.origin.decrement(Vertex.NULL);\r\n                    for (let i = target.childrn.length-1; i >= 0; --i) {\r\n                        if (target.childrn[i] === this.origin) {\r\n                            target.childrn.splice(i, 1);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    deregister(target : Vertex) : void {\r\n        if (this.registered) {\r\n            this.registered = false;\r\n            if (this.deregister_ !== null)\r\n                this.deregister_();\r\n        }\r\n    }\r\n}\r\n\r\nexport enum Color { black, gray, white, purple };\r\nlet roots : Vertex[] = [];\r\nlet nextID : number = 0;\r\nlet verbose : boolean = false;\r\n\r\nexport function setVerbose(v : boolean) : void { verbose = v; }\r\n\r\nexport function describeAll(v : Vertex, visited : Set<number>)\r\n{\r\n    if (visited.contains(v.id)) return;\r\n    console.log(v.descr());\r\n    visited.add(v.id);\r\n    let chs = v.children();\r\n    for (let i = 0; i < chs.length; i++)\r\n        describeAll(chs[i], visited);\r\n}\r\n\r\nexport class Vertex {\r\n    static NULL : Vertex = new Vertex(\"user\", 1e12, []);\r\n    static collectingCycles : boolean = false;\r\n    static toBeFreedList : Vertex[] = [];\r\n    id : number;\r\n\r\n\tconstructor(name : string, rank : number, sources : Source[]) {\r\n\t    this.name = name;\r\n\t\tthis.rank = rank;\r\n\t\tthis.sources = sources;\r\n\t\tthis.id = nextID++;\r\n\t}\r\n\tname : string;\r\n    rank : number;\r\n    sources : Source[];\r\n    targets : Vertex[] = [];\r\n    childrn : Vertex[] = [];\r\n    refCount() : number { return this.targets.length; };\r\n    visited : boolean = false;\r\n    register(target : Vertex) : boolean {\r\n        return this.increment(target);\r\n    }\r\n    deregister(target : Vertex) : void {\r\n        if (verbose)\r\n            console.log(\"deregister \"+this.descr()+\" => \"+target.descr());\r\n        this.decrement(target);\r\n        Transaction._collectCyclesAtEnd();\r\n    }\r\n    private incRefCount(target : Vertex) : boolean {\r\n        let anyChanged : boolean = false;\r\n        if (this.refCount() == 0) {\r\n            for (let i = 0; i < this.sources.length; i++)\r\n                this.sources[i].register(this);\r\n        }\r\n        this.targets.push(target);\r\n        target.childrn.push(this);\r\n        if (target.ensureBiggerThan(this.rank))\r\n            anyChanged = true;\r\n        totalRegistrations++;\r\n        return anyChanged;\r\n    }\r\n\r\n    private decRefCount(target : Vertex) : void {\r\n        if (verbose)\r\n            console.log(\"DEC \"+this.descr());\r\n        let matched = false;\r\n        for (let i = target.childrn.length-1; i >= 0; i--)\r\n            if (target.childrn[i] === this) {\r\n                target.childrn.splice(i, 1);\r\n                break;\r\n            }\r\n        for (let i = 0; i < this.targets.length; i++)\r\n            if (this.targets[i] === target) {\r\n                this.targets.splice(i, 1);\r\n                matched = true;\r\n                break;\r\n            }\r\n        if (matched) {\r\n            if (this.refCount() == 0) {\r\n                for (let i = 0; i < this.sources.length; i++)\r\n                    this.sources[i].deregister(this);\r\n            }\r\n            totalRegistrations--;\r\n        }\r\n    }\r\n\r\n    addSource(src : Source) : void {\r\n        this.sources.push(src);\r\n        if (this.refCount() > 0)\r\n            src.register(this);\r\n    }\r\n\r\n\tprivate ensureBiggerThan(limit : number) : boolean {\r\n        if (this.visited) {\r\n            // Undoing cycle detection for now until TimerSystem.ts ranks are checked.\r\n            //throw new Error(\"Vertex cycle detected.\");\r\n            return false;\r\n        }\r\n\t\tif (this.rank > limit)\r\n\t\t\treturn false;\r\n\r\n        this.visited = true;\r\n\t\tthis.rank = limit + 1;\r\n\t\tfor (let i = 0; i < this.targets.length; i++)\r\n\t\t\tthis.targets[i].ensureBiggerThan(this.rank);\r\n        this.visited = false;\r\n\t\treturn true;\r\n\t}\r\n\r\n\tdescr() : string {\r\n        let colStr : string = null;\r\n        switch (this.color) {\r\n        case Color.black: colStr = \"black\"; break;\r\n        case Color.gray:  colStr = \"gray\"; break;\r\n        case Color.white: colStr = \"white\"; break;\r\n        case Color.purple: colStr = \"purple\"; break;\r\n        }\r\n        let str = this.id+\" \"+this.name+\" [\"+this.refCount()+\"/\"+this.refCountAdj+\"] \"+colStr+\" ->\";\r\n        let chs = this.children();\r\n        for (let i = 0; i < chs.length; i++) {\r\n            str = str + \" \" + chs[i].id;\r\n        }\r\n        return str;\r\n\t}\r\n\r\n\t// --------------------------------------------------------\r\n\t// Synchronous Cycle Collection algorithm presented in \"Concurrent\r\n\t// Cycle Collection in Reference Counted Systems\" by David F. Bacon\r\n\t// and V.T. Rajan.\r\n\r\n    color : Color = Color.black;\r\n    buffered : boolean = false;\r\n    refCountAdj : number = 0;\r\n\r\n\tchildren() : Vertex[] { return this.childrn; }\r\n\r\n\tincrement(referrer : Vertex) : boolean {\r\n\t    return this.incRefCount(referrer);\r\n\t}\r\n\r\n\tdecrement(referrer : Vertex) : void {\r\n\t    this.decRefCount(referrer);\r\n\t    if (this.refCount() == 0)\r\n\t        this.release();\r\n        else\r\n            this.possibleRoots();\r\n\t}\r\n\r\n    release() : void {\r\n        this.color = Color.black;\r\n        if (!this.buffered)\r\n            this.free();\r\n    }\r\n\r\n    free() : void {\r\n        while (this.targets.length > 0)\r\n            this.decRefCount(this.targets[0]);\r\n    }\r\n\r\n\tpossibleRoots() : void {\r\n\t    if (this.color != Color.purple) {\r\n\t        this.color = Color.purple;\r\n\t        if (!this.buffered) {\r\n                this.buffered = true;\r\n                roots.push(this);\r\n            }\r\n        }\r\n\t}\r\n\r\n\tstatic collectCycles() : void {\r\n        if (Vertex.collectingCycles) {\r\n            return;\r\n        }\r\n        try {\r\n            Vertex.collectingCycles = true;\r\n            Vertex.markRoots();\r\n            Vertex.scanRoots();\r\n            Vertex.collectRoots();\r\n            for (let i = Vertex.toBeFreedList.length-1; i >= 0; --i) {\r\n                let vertex = Vertex.toBeFreedList.splice(i, 1)[0];\r\n                vertex.free();\r\n            }\r\n        } finally {\r\n            Vertex.collectingCycles = false;\r\n        }\r\n\t}\r\n\r\n\tstatic markRoots() : void {\r\n        const newRoots : Vertex[] = [];\r\n        // check refCountAdj was restored to zero before mark roots\r\n        if (verbose) {\r\n            let stack: Vertex[] = roots.slice(0);\r\n            let visited: Set<number> = new Set();\r\n            while (stack.length != 0) {\r\n                let vertex = stack.pop();\r\n                if (visited.contains(vertex.id)) {\r\n                    continue;\r\n                }\r\n                visited.add(vertex.id);\r\n                if (vertex.refCountAdj != 0) {\r\n                    console.log(\"markRoots(): reachable refCountAdj was not reset to zero: \" + vertex.descr());\r\n                }\r\n                for (let i = 0; i < vertex.childrn.length; ++i) {\r\n                    let child = vertex.childrn[i];\r\n                    stack.push(child);\r\n                }\r\n            }\r\n        }\r\n        //\r\n\t    for (let i = 0; i < roots.length; i++) {\r\n            if (verbose)\r\n                console.log(\"markRoots \"+roots[i].descr());  // ###\r\n\t        if (roots[i].color == Color.purple) {\r\n\t            roots[i].markGray();\r\n\t            newRoots.push(roots[i]);\r\n            }\r\n\t        else {\r\n\t            roots[i].buffered = false;\r\n                if (roots[i].color == Color.black && roots[i].refCount() == 0)\r\n\t                Vertex.toBeFreedList.push(roots[i]);\r\n            }\r\n\t    }\r\n\t    roots = newRoots;\r\n\t}\r\n\r\n\tstatic scanRoots() : void {\r\n\t    for (let i = 0; i < roots.length; i++)\r\n\t        roots[i].scan();\r\n\t}\r\n\r\n\tstatic collectRoots() : void {\r\n\t    for (let i = 0; i < roots.length; i++) {\r\n\t        roots[i].buffered = false;\r\n\t        roots[i].collectWhite();\r\n        }\r\n        if (verbose) { // double check adjRefCount is zero for all vertices reachable by roots\r\n            let stack: Vertex[] = roots.slice(0);\r\n            let visited: Set<number> = new Set();\r\n            while (stack.length != 0) {\r\n                let vertex = stack.pop();\r\n                if (visited.contains(vertex.id)) {\r\n                    continue;\r\n                }\r\n                visited.add(vertex.id);\r\n                if (vertex.refCountAdj != 0) {\r\n                    console.log(\"collectRoots(): reachable refCountAdj was not reset to zero: \" + vertex.descr());\r\n                }\r\n                for (let i = 0; i < vertex.childrn.length; ++i) {\r\n                    let child = vertex.childrn[i];\r\n                    stack.push(child);\r\n                }\r\n            }\r\n        }\r\n\t    roots = [];\r\n\t}\r\n\r\n\tmarkGray() : void {\r\n\t    if (this.color != Color.gray) {\r\n\t        this.color = Color.gray;\r\n\t        let chs = this.children();\r\n\t        for (let i = 0; i < chs.length; i++) {\r\n\t            chs[i].refCountAdj--;\r\n                if (verbose)\r\n                    console.log(\"markGray \"+this.descr());\r\n\t            chs[i].markGray();\r\n            }\r\n\t    }\r\n\t}\r\n\r\n\tscan() : void {\r\n\t    if (verbose)\r\n            console.log(\"scan \"+this.descr());\r\n\t    if (this.color == Color.gray) {\r\n\t        if (this.refCount()+this.refCountAdj > 0)\r\n\t            this.scanBlack();\r\n\t        else {\r\n\t            this.color = Color.white;\r\n                if (verbose)\r\n                    console.log(\"scan WHITE \"+this.descr());\r\n                let chs = this.children();\r\n                for (let i = 0; i < chs.length; i++)\r\n                    chs[i].scan();\r\n\t        }\r\n\t    }\r\n\t}\r\n\r\n\tscanBlack() : void {\r\n        this.refCountAdj = 0;\r\n\t    this.color = Color.black;\r\n        let chs = this.children();\r\n        for (let i = 0; i < chs.length; i++) {\r\n            if (verbose)\r\n                console.log(\"scanBlack \"+this.descr());\r\n            if (chs[i].color != Color.black)\r\n                chs[i].scanBlack();\r\n        }\r\n\t}\r\n\r\n\tcollectWhite() : void {\r\n\t    if (this.color == Color.white && !this.buffered) {\r\n            if (verbose)\r\n                console.log(\"collectWhite \"+this.descr());\r\n\t        this.color = Color.black;\r\n\t        this.refCountAdj = 0;\r\n            let chs = this.children();\r\n            for (let i = 0; i < chs.length; i++)\r\n                chs[i].collectWhite();\r\n            Vertex.toBeFreedList.push(this);\r\n\t    }\r\n\t}\r\n}\r\n", "import { Stream } from \"./Stream\";\r\nimport { Cell } from \"./Cell\";\r\nimport { Source } from \"./Vertex\";\r\n\r\nexport class Lambda1<A,B> {\r\n    constructor(f : (a : A) => B,\r\n                deps : Array<Stream<any>|Cell<any>>) {\r\n        this.f = f;\r\n        this.deps = deps;\r\n    }\r\n    f : (a : A) => B;\r\n    deps : Array<Stream<any>|Cell<any>>;\r\n}\r\n\r\nexport function lambda1<A,B>(f : (a : A) => B,\r\n                deps : Array<Stream<any>|Cell<any>>) : Lambda1<A,B>\r\n{\r\n    return new Lambda1(f, deps);\r\n}\r\n\r\nexport function Lambda1_deps<A,B>(f : ((a : A) => B) | Lambda1<A,B>) : Array<Stream<any>|Cell<any>> {\r\n    if (f instanceof Lambda1)\r\n        return f.deps;\r\n    else\r\n        return [];\r\n}\r\n\r\nexport function Lambda1_toFunction<A,B>(f : ((a : A) => B) | Lambda1<A,B>) : (a : A) => B {\r\n    if (f instanceof Lambda1)\r\n        return f.f;\r\n    else\r\n        return <(a : A) => B>f;\r\n}\r\n\r\nexport class Lambda2<A,B,C> {\r\n    constructor(f : (a : A, b : B) => C,\r\n                deps : Array<Stream<any>|Cell<any>>) {\r\n        this.f = f;\r\n        this.deps = deps;\r\n    }\r\n    f : (a : A, b : B) => C;\r\n    deps : Array<Stream<any>|Cell<any>>;\r\n}\r\n\r\nexport function lambda2<A,B,C>(f : (a : A, b : B) => C,\r\n                deps : Array<Stream<any>|Cell<any>>) : Lambda2<A,B,C>\r\n{\r\n    return new Lambda2(f, deps);\r\n}\r\n\r\nexport function Lambda2_deps<A,B,C>(f : ((a : A, b : B) => C) | Lambda2<A,B,C>) : Array<Stream<any>|Cell<any>> {\r\n    if (f instanceof Lambda2)\r\n        return f.deps;\r\n    else\r\n        return [];\r\n}\r\n\r\nexport function Lambda2_toFunction<A,B,C>(f : ((a : A, b : B) => C) | Lambda2<A,B,C>) : (a : A, b : B) => C {\r\n    if (f instanceof Lambda2)\r\n        return f.f;\r\n    else\r\n        return <(a : A, b : B) => C>f;\r\n}\r\n\r\nexport class Lambda3<A,B,C,D> {\r\n    constructor(f : (a : A, b : B, c : C) => D,\r\n                deps : Array<Stream<any>|Cell<any>>) {\r\n        this.f = f;\r\n        this.deps = deps;\r\n    }\r\n    f : (a : A, b : B, c : C) => D;\r\n    deps : Array<Stream<any>|Cell<any>>;\r\n}\r\n\r\nexport function lambda3<A,B,C,D>(f : (a : A, b : B, c : C) => D,\r\n                deps : Array<Stream<any>|Cell<any>>) : Lambda3<A,B,C,D>\r\n{\r\n    return new Lambda3(f, deps);\r\n}\r\n\r\nexport function Lambda3_deps<A,B,C,D>(f : ((a : A, b : B, c : C) => D)\r\n        | Lambda3<A,B,C,D>) : Array<Stream<any>|Cell<any>> {\r\n    if (f instanceof Lambda3)\r\n        return f.deps;\r\n    else\r\n        return [];\r\n}\r\n\r\nexport function Lambda3_toFunction<A,B,C,D>(f : ((a : A, b : B, c : C) => D) | Lambda3<A,B,C,D>) : (a : A, b : B, c : C) => D {\r\n    if (f instanceof Lambda3)\r\n        return f.f;\r\n    else\r\n        return <(a : A, b : B, c : C) => D>f;\r\n}\r\n\r\nexport class Lambda4<A,B,C,D,E> {\r\n    constructor(f : (a : A, b : B, c : C, d : D) => E,\r\n                deps : Array<Stream<any>|Cell<any>>) {\r\n        this.f = f;\r\n        this.deps = deps;\r\n    }\r\n    f : (a : A, b : B, c : C, d : D) => E;\r\n    deps : Array<Stream<any>|Cell<any>>;\r\n}\r\n\r\nexport function lambda4<A,B,C,D,E>(f : (a : A, b : B, c : C, d : D) => E,\r\n                deps : Array<Stream<any>|Cell<any>>) : Lambda4<A,B,C,D,E>\r\n{\r\n    return new Lambda4(f, deps);\r\n}\r\n\r\nexport function Lambda4_deps<A,B,C,D,E>(f : ((a : A, b : B, c : C, d : D) => E)\r\n        | Lambda4<A,B,C,D,E>) : Array<Stream<any>|Cell<any>> {\r\n    if (f instanceof Lambda4)\r\n        return f.deps;\r\n    else\r\n        return [];\r\n}\r\n\r\nexport function Lambda4_toFunction<A,B,C,D,E>(f : ((a : A, b : B, c : C, d : D) => E)\r\n        | Lambda4<A,B,C,D,E>) : (a : A, b : B, c : C, d : D) => E {\r\n    if (f instanceof Lambda4)\r\n        return f.f;\r\n    else\r\n        return <(a : A, b : B, c : C, d : D) => E>f;\r\n}\r\n\r\nexport class Lambda5<A,B,C,D,E,F> {\r\n    constructor(f : (a : A, b : B, c : C, d : D, e : E) => F,\r\n                deps : Array<Stream<any>|Cell<any>>) {\r\n        this.f = f;\r\n        this.deps = deps;\r\n    }\r\n    f : (a : A, b : B, c : C, d : D, e : E) => F;\r\n    deps : Array<Stream<any>|Cell<any>>;\r\n}\r\n\r\nexport function lambda5<A,B,C,D,E,F>(f : (a : A, b : B, c : C, d : D, e : E) => F,\r\n                deps : Array<Stream<any>|Cell<any>>) : Lambda5<A,B,C,D,E,F>\r\n{\r\n    return new Lambda5(f, deps);\r\n}\r\n\r\nexport function Lambda5_deps<A,B,C,D,E,F>(f : ((a : A, b : B, c : C, d : D, e : E) => F)\r\n        | Lambda5<A,B,C,D,E,F>) : Array<Stream<any>|Cell<any>> {\r\n    if (f instanceof Lambda5)\r\n        return f.deps;\r\n    else\r\n        return [];\r\n}\r\n\r\nexport function Lambda5_toFunction<A,B,C,D,E,F>(f : ((a : A, b : B, c : C, d : D, e : E) => F)\r\n        | Lambda5<A,B,C,D,E,F>) : (a : A, b : B, c : C, d : D, e : E) => F {\r\n    if (f instanceof Lambda5)\r\n        return f.f;\r\n    else\r\n        return <(a : A, b : B, c : C, d : D, e : E) => F>f;\r\n}\r\n\r\nexport class Lambda6<A,B,C,D,E,F,G> {\r\n    constructor(f : (a : A, b : B, c : C, d : D, e : E, f : F) => G,\r\n                deps : Array<Stream<any>|Cell<any>>) {\r\n        this.f = f;\r\n        this.deps = deps;\r\n    }\r\n    f : (a : A, b : B, c : C, d : D, e : E, f : F) => G;\r\n    deps : Array<Stream<any>|Cell<any>>;\r\n}\r\n\r\nexport function lambda6<A,B,C,D,E,F,G>(f : (a : A, b : B, c : C, d : D, e : E, f : F) => G,\r\n                deps : Array<Stream<any>|Cell<any>>) : Lambda6<A,B,C,D,E,F,G>\r\n{\r\n    return new Lambda6(f, deps);\r\n}\r\n\r\nexport function Lambda6_deps<A,B,C,D,E,F,G>(f : ((a : A, b : B, c : C, d : D, e : E, f : F) => G)\r\n        | Lambda6<A,B,C,D,E,F,G>) : Array<Stream<any>|Cell<any>> {\r\n    if (f instanceof Lambda6)\r\n        return f.deps;\r\n    else\r\n        return [];\r\n}\r\n\r\nexport function Lambda6_toFunction<A,B,C,D,E,F,G>(f : ((a : A, b : B, c : C, d : D, e : E, f : F) => G)\r\n        | Lambda6<A,B,C,D,E,F,G>) : (a : A, b : B, c : C, d : D, e : E, f : F) => G {\r\n    if (f instanceof Lambda6)\r\n        return f.f;\r\n    else\r\n        return <(a : A, b : B, c : C, d : D, e : E, f : F) => G>f;\r\n}\r\n\r\nexport function toSources(deps : Array<Stream<any>|Cell<any>>) : Source[] {\r\n    const ss : Source[] = [];\r\n    for (let i = 0; i < deps.length; i++) {\r\n        const dep = deps[i];\r\n        ss.push(new Source(dep.getVertex__(), null));\r\n    }\r\n    return ss;\r\n}\r\n", "/**\r\n * A representation for a value that may not be available until the current\r\n * transaction is closed.\r\n */\r\nexport class Lazy<A> {\r\n    constructor(f : () => A) {\r\n        this.f = f;\r\n    }\r\n\r\n    private f : () => A;\r\n\r\n    /**\r\n     * Get the value if available, throwing an exception if not.\r\n     * In the general case this should only be used in subsequent transactions to\r\n     * when the Lazy was obtained.\r\n     */\r\n    get() : A {\r\n        return this.f();\r\n    }\r\n\r\n    /**\r\n     * Map the lazy value according to the specified function, so the returned Lazy reflects\r\n     * the value of the function applied to the input Lazy's value.\r\n     * @param f Function to apply to the contained value. It must be <em>referentially transparent</em>.\r\n     */\r\n    map<B>(f : (a : A) => B) {\r\n        return new Lazy<B>(() => { return f(this.f()); });\r\n    }\r\n\r\n\t/**\r\n\t * Lift a binary function into lazy values, so the returned Lazy reflects\r\n     * the value of the function applied to the input Lazys' values.\r\n\t */\r\n    lift<B,C>(b : Lazy<B>, f : (a : A, b : B) => C) : Lazy<C> {\r\n        return new Lazy<C>(() => { return f(this.f(), b.f()); });\r\n    }\r\n\r\n\t/**\r\n\t * Lift a ternary function into lazy values, so the returned Lazy reflects\r\n     * the value of the function applied to the input Lazys' values.\r\n\t */\r\n    lift3<B,C,D>(b : Lazy<B>, c : Lazy<C>, f : (a : A, b : B, c : C) => D) : Lazy<D> {\r\n        return new Lazy<D>(() => { return f(this.f(), b.f(), c.f()); });\r\n    }\r\n\r\n\t/**\r\n\t * Lift a quaternary function into lazy values, so the returned Lazy reflects\r\n     * the value of the function applied to the input Lazys' values.\r\n\t */\r\n    lift4<B,C,D,E>(b : Lazy<B>, c : Lazy<C>, d : Lazy<D>, f : (a : A, b : B, c : C, d : D) => E) : Lazy<E> {\r\n        return new Lazy<E>(() => { return f(this.f(), b.f(), c.f(), d.f()); });\r\n    }\r\n}\r\n", "export class Unit {\r\n    static UNIT : Unit = new Unit();\r\n    constructor() {}\r\n}\r\n", "import { Stream, StreamWithSend } from \"./Stream\";\r\nimport { Cell } from \"./Cell\";\r\nimport { Transaction } from \"./Transaction\";\r\nimport { Unit } from \"./Unit\";\r\nimport { Source, Vertex } from \"./Vertex\";\r\n\r\nexport class Operational {\r\n    /**\r\n     * A stream that gives the updates/steps for a {@link Cell}.\r\n     * <P>\r\n     * This is an OPERATIONAL primitive, which is not part of the main Sodium\r\n     * API. It breaks the property of non-detectability of cell steps/updates.\r\n     * The rule with this primitive is that you should only use it in functions\r\n     * that do not allow the caller to detect the cell updates.\r\n     */\r\n    static updates<A>(c : Cell<A>) : Stream<A> {\r\n        /*  Don't think this is needed\r\n        const out = new StreamWithSend<A>(null);\r\n        out.setVertex__(new Vertex(\"updates\", 0, [\r\n                new Source(\r\n                    c.getStream__().getVertex__(),\r\n                    () => {\r\n                        return c.getStream__().listen_(out.getVertex__(), (a : A) => {\r\n                            out.send_(a);\r\n                        }, false);\r\n                    }\r\n                ),\r\n                new Source(\r\n                    c.getVertex__(),\r\n                    () => {\r\n                        return () => { };\r\n                    }\r\n                )\r\n            ]\r\n        ));\r\n        return out;\r\n        */\r\n        return c.getStream__();\r\n    }\r\n\r\n    /**\r\n     * A stream that is guaranteed to fire once in the transaction where value() is invoked, giving\r\n     * the current value of the cell, and thereafter behaves like {@link updates(Cell)},\r\n     * firing for each update/step of the cell's value.\r\n     * <P>\r\n     * This is an OPERATIONAL primitive, which is not part of the main Sodium\r\n     * API. It breaks the property of non-detectability of cell steps/updates.\r\n     * The rule with this primitive is that you should only use it in functions\r\n     * that do not allow the caller to detect the cell updates.\r\n     */\r\n    static value<A>(c : Cell<A>) : Stream<A> {\r\n        return Transaction.run(() => {\r\n            const sSpark = new StreamWithSend<Unit>();\r\n            Transaction.currentTransaction.prioritized(sSpark.getVertex__(), () => {\r\n                sSpark.send_(Unit.UNIT);\r\n            });\r\n            const sInitial = sSpark.snapshot1(c);\r\n            return Operational.updates(c).orElse(sInitial);\r\n        });\r\n    }\r\n\r\n\t/**\r\n\t * Push each event onto a new transaction guaranteed to come before the next externally\r\n\t * initiated transaction. Same as {@link split(Stream)} but it works on a single value.\r\n\t */\r\n\tstatic defer<A>(s : Stream<A>) : Stream<A> {\r\n\t    return Operational.split<A>(s.map((a : A) => {\r\n\t        return [a];\r\n\t    }));\r\n    }\r\n\r\n\t/**\r\n\t * Push each event in the list onto a newly created transaction guaranteed\r\n\t * to come before the next externally initiated transaction. Note that the semantics\r\n\t * are such that two different invocations of split() can put events into the same\r\n\t * new transaction, so the resulting stream's events could be simultaneous with\r\n\t * events output by split() or {@link defer(Stream)} invoked elsewhere in the code.\r\n\t */\r\n\tstatic split<A>(s : Stream<Array<A>>) : Stream<A> {\r\n\t    const out = new StreamWithSend<A>(null);\r\n        out.setVertex__(new Vertex(\"split\", 0, [\r\n                new Source(\r\n                    s.getVertex__(),\r\n                    () => {\r\n                        out.getVertex__().childrn.push(s.getVertex__());\r\n                        let cleanups: (()=>void)[] = [];\r\n                        cleanups.push(\r\n                            s.listen_(Vertex.NULL, (as : Array<A>) => {\r\n                                for (let i = 0; i < as.length; i++) {\r\n                                    Transaction.currentTransaction.post(i, () => {\r\n                                        Transaction.run(() => {\r\n                                            out.send_(as[i]);\r\n                                        });\r\n                                    });\r\n                                }\r\n                            }, false)\r\n                        );\r\n                        cleanups.push(() => {\r\n                            let chs = out.getVertex__().childrn;\r\n                            for (let i = chs.length-1; i >= 0; --i) {\r\n                                if (chs[i] == s.getVertex__()) {\r\n                                    chs.splice(i, 1);\r\n                                    break;\r\n                                }\r\n                            }\r\n                        });\r\n                        return () => {\r\n                            cleanups.forEach(cleanup => cleanup());\r\n                            cleanups.splice(0, cleanups.length);\r\n                        }\r\n                    }\r\n                )\r\n            ]\r\n        ));\r\n        return out;\r\n    }\r\n}\r\n", "export class Tuple2<A,B> {\r\n    constructor(a : A, b : B) {\r\n        this.a = a;\r\n        this.b = b;\r\n    }\r\n    a : A;\r\n    b : B;\r\n}\r\n", "import { Lambda1, Lambda1_deps, Lambda1_toFunction,\r\n         Lambda2, Lambda2_deps, Lambda2_toFunction,\r\n         Lambda3, Lambda3_deps, Lambda3_toFunction,\r\n         Lambda4, Lambda4_deps, Lambda4_toFunction,\r\n         Lambda5, Lambda5_deps, Lambda5_toFunction,\r\n         Lambda6, Lambda6_deps, Lambda6_toFunction,\r\n         toSources, lambda1 } from \"./Lambda\";\r\nimport { Source, Vertex } from \"./Vertex\";\r\nimport { Transaction } from \"./Transaction\";\r\nimport { Lazy } from \"./Lazy\";\r\nimport { Listener } from \"./Listener\";\r\nimport { Stream, StreamWithSend } from \"./Stream\";\r\nimport { Operational } from \"./Operational\";\r\nimport { Tuple2 } from \"./Tuple2\";\r\n\r\nclass LazySample<A> {\r\n    constructor(cell : Cell<A>) {\r\n        this.cell = cell;\r\n    }\r\n    cell : Cell<A>;\r\n    hasValue : boolean = false;\r\n    value : A = null;\r\n}\r\n\r\nclass ApplyState<A,B> {\r\n    constructor() {}\r\n    f : (a : A) => B = null;\r\n    f_present : boolean = false;\r\n    a : A = null;\r\n    a_present : boolean = false;\r\n}\r\n\r\nexport class Cell<A> {\r\n\tprivate str : Stream<A>;\r\n\tprotected value : A;\r\n\tprotected valueUpdate : A;\r\n\tprivate cleanup : () => void;\r\n\tprotected lazyInitValue : Lazy<A>;  // Used by LazyCell\r\n\tprivate vertex : Vertex;\r\n\r\n    constructor(initValue : A, str? : Stream<A>) {\r\n        this.value = initValue;\r\n        if (!str) {\r\n            this.str = new Stream<A>();\r\n            this.vertex = new Vertex(\"ConstCell\", 0, []);\r\n        }\r\n        else\r\n            Transaction.run(() => this.setStream(str));\r\n    }\r\n\r\n    protected setStream(str : Stream<A>) {\r\n        this.str = str;\r\n        const me = this,\r\n              src = new Source(\r\n                str.getVertex__(),\r\n                () => {\r\n                    return str.listen_(me.vertex, (a : A) => {\r\n                        if (me.valueUpdate == null) {\r\n                            Transaction.currentTransaction.last(() => {\r\n                                me.value = me.valueUpdate;\r\n                                me.lazyInitValue = null;\r\n                                me.valueUpdate = null;\r\n                            });\r\n                        }\r\n                        me.valueUpdate = a;\r\n                    }, false);\r\n                }\r\n            );\r\n        this.vertex = new Vertex(\"Cell\", 0, [src]);\r\n        // We do a trick here of registering the source for the duration of the current\r\n        // transaction so that we are guaranteed to catch any stream events that\r\n        // occur in the same transaction.\r\n        //\r\n        // A new temporary vertex null is constructed here as a performance work-around to avoid\r\n        // having too many children in Vertex.NULL as a deregister operation is O(n^2) where\r\n        // n is the number of children in the vertex.\r\n        let tmpVertexNULL = new Vertex(\"Cell::setStream\", 1e12, []);\r\n        this.vertex.register(tmpVertexNULL);\r\n        Transaction.currentTransaction.last(() => {\r\n            this.vertex.deregister(tmpVertexNULL);\r\n        });\r\n    }\r\n\r\n    getVertex__() : Vertex {\r\n        return this.vertex;\r\n    }\r\n\r\n    getStream__() : Stream<A> {  // TO DO: Figure out how to hide this\r\n        return this.str;\r\n    }\r\n\r\n    /**\r\n     * Sample the cell's current value.\r\n     * <p>\r\n     * It should generally be avoided in favour of {@link listen(Handler)} so you don't\r\n     * miss any updates, but in many circumstances it makes sense.\r\n     * <p>\r\n     * NOTE: In the Java and other versions of Sodium, using sample() inside map(), filter() and\r\n     * merge() is encouraged. In the Javascript/Typescript version, not so much, for the\r\n     * following reason: The memory management is different in the Javascript version, and this\r\n     * requires us to track all dependencies. In order for the use of sample() inside\r\n     * a closure to be correct, the cell that was sample()d inside the closure would have to be\r\n     * declared explicitly using the helpers lambda1(), lambda2(), etc. Because this is\r\n     * something that can be got wrong, we don't encourage this kind of use of sample() in\r\n     * Javascript. Better and simpler to use snapshot().\r\n     * <p>\r\n     * NOTE: If you need to sample() a cell, you have to make sure it's \"alive\" in terms of\r\n     * memory management or it will ignore updates. To make a cell work correctly\r\n     * with sample(), you have to ensure that it's being used. One way to guarantee this is\r\n     * to register a dummy listener on the cell. It will also work to have it referenced\r\n     * by something that is ultimately being listened to.\r\n     */\r\n    sample() : A {\r\n        return Transaction.run(() => { return this.sampleNoTrans__(); });\r\n    }\r\n\r\n    sampleNoTrans__() : A {  // TO DO figure out how to hide this\r\n        return this.value;\r\n    }\r\n\r\n    /**\r\n     * A variant of {@link sample()} that works with {@link CellLoop}s when they haven't been looped yet.\r\n     * It should be used in any code that's general enough that it could be passed a {@link CellLoop}.\r\n     * @see Stream#holdLazy(Lazy) Stream.holdLazy()\r\n     */\r\n    sampleLazy() : Lazy<A> {\r\n        const me = this;\r\n        return Transaction.run(() => me.sampleLazyNoTrans__());\r\n    }\r\n\r\n    sampleLazyNoTrans__() : Lazy<A> {  // TO DO figure out how to hide this\r\n        const me = this,\r\n            s = new LazySample<A>(me);\r\n        Transaction.currentTransaction.sample(() => {\r\n            s.value = me.valueUpdate != null ? me.valueUpdate : me.sampleNoTrans__();\r\n            s.hasValue = true;\r\n            s.cell = null;\r\n        });\r\n        return new Lazy<A>(() => {\r\n            if (s.hasValue)\r\n                return s.value;\r\n            else\r\n                return s.cell.sample();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Transform the cell's value according to the supplied function, so the returned Cell\r\n     * always reflects the value of the function applied to the input Cell's value.\r\n     * @param f Function to apply to convert the values. It must be <em>referentially transparent</em>.\r\n     */\r\n    map<B>(f : ((a : A) => B) | Lambda1<A,B>) : Cell<B> {\r\n        const c = this;\r\n        return Transaction.run(() =>\r\n            Operational.updates(c).map(f).holdLazy(c.sampleLazy().map(Lambda1_toFunction(f)))\r\n        );\r\n    }\r\n\r\n\t/**\r\n\t * Lift a binary function into cells, so the returned Cell always reflects the specified\r\n\t * function applied to the input cells' values.\r\n\t * @param fn Function to apply. It must be <em>referentially transparent</em>.\r\n\t */\r\n\tlift<B,C>(b : Cell<B>,\r\n\t          fn0 : ((a : A, b : B) => C) |\r\n\t                Lambda2<A,B,C>) : Cell<C> {\r\n        const fn = Lambda2_toFunction(fn0),\r\n            cf = this.map((aa : A) => (bb : B) => fn(aa, bb));\r\n        return Cell.apply(cf, b,\r\n            toSources(Lambda2_deps(fn0)));\r\n\t}\r\n\r\n\t/**\r\n\t * Lift a ternary function into cells, so the returned Cell always reflects the specified\r\n\t * function applied to the input cells' values.\r\n\t * @param fn Function to apply. It must be <em>referentially transparent</em>.\r\n\t */\r\n\tlift3<B,C,D>(b : Cell<B>, c : Cell<C>,\r\n\t             fn0 : ((a : A, b : B, c : C) => D) |\r\n\t                   Lambda3<A,B,C,D>) : Cell<D> {\r\n        const fn = Lambda3_toFunction(fn0),\r\n            mf : (aa : A) => (bb : B) => (cc : C) => D =\r\n                 (aa : A) => (bb : B) => (cc : C) => fn(aa, bb, cc),\r\n            cf = this.map(mf);\r\n        return Cell.apply(\r\n                   Cell.apply<B, (c : C) => D>(cf, b),\r\n                   c,\r\n                   toSources(Lambda3_deps(fn0)));\r\n\t}\r\n\r\n\t/**\r\n\t * Lift a quaternary function into cells, so the returned Cell always reflects the specified\r\n\t * function applied to the input cells' values.\r\n\t * @param fn Function to apply. It must be <em>referentially transparent</em>.\r\n\t */\r\n\tlift4<B,C,D,E>(b : Cell<B>, c : Cell<C>, d : Cell<D>,\r\n\t               fn0 : ((a : A, b : B, c : C, d : D) => E) |\r\n\t                     Lambda4<A,B,C,D,E>) : Cell<E> {\r\n        const fn = Lambda4_toFunction(fn0),\r\n            mf : (aa : A) => (bb : B) => (cc : C) => (dd : D) => E =\r\n                 (aa : A) => (bb : B) => (cc : C) => (dd : D) => fn(aa, bb, cc, dd),\r\n            cf = this.map(mf);\r\n        return Cell.apply(\r\n                   Cell.apply(\r\n                       Cell.apply<B, (c : C) => (d : D) => E>(cf, b),\r\n                       c),\r\n                   d,\r\n                   toSources(Lambda4_deps(fn0)));\r\n\t}\r\n\r\n\t/**\r\n\t * Lift a 5-argument function into cells, so the returned Cell always reflects the specified\r\n\t * function applied to the input cells' values.\r\n\t * @param fn Function to apply. It must be <em>referentially transparent</em>.\r\n\t */\r\n\tlift5<B,C,D,E,F>(b : Cell<B>, c : Cell<C>, d : Cell<D>, e : Cell<E>,\r\n\t                 fn0 : ((a : A, b : B, c : C, d : D, e : E) => F) |\r\n\t                       Lambda5<A,B,C,D,E,F>) : Cell<F> {\r\n        const fn = Lambda5_toFunction(fn0),\r\n            mf : (aa : A) => (bb : B) => (cc : C) => (dd : D) => (ee : E) => F =\r\n                 (aa : A) => (bb : B) => (cc : C) => (dd : D) => (ee : E) => fn(aa, bb, cc, dd, ee),\r\n            cf = this.map(mf);\r\n        return Cell.apply(\r\n                   Cell.apply(\r\n                       Cell.apply(\r\n                           Cell.apply<B, (c : C) => (d : D) => (e : E) => F>(cf, b),\r\n                           c),\r\n                       d),\r\n                   e,\r\n                   toSources(Lambda5_deps(fn0)));\r\n\t}\r\n\r\n\t/**\r\n\t * Lift a 6-argument function into cells, so the returned Cell always reflects the specified\r\n\t * function applied to the input cells' values.\r\n\t * @param fn Function to apply. It must be <em>referentially transparent</em>.\r\n\t */\r\n\tlift6<B,C,D,E,F,G>(b : Cell<B>, c : Cell<C>, d : Cell<D>, e : Cell<E>, f : Cell<F>,\r\n\t                   fn0 : ((a : A, b : B, c : C, d : D, e : E, f : F) => G) |\r\n\t                         Lambda6<A,B,C,D,E,F,G>) : Cell<G> {\r\n        const fn = Lambda6_toFunction(fn0),\r\n            mf : (aa : A) => (bb : B) => (cc : C) => (dd : D) => (ee : E) => (ff : F) => G =\r\n                 (aa : A) => (bb : B) => (cc : C) => (dd : D) => (ee : E) => (ff : F) => fn(aa, bb, cc, dd, ee, ff),\r\n            cf = this.map(mf);\r\n        return Cell.apply(\r\n                   Cell.apply(\r\n                       Cell.apply(\r\n                           Cell.apply(\r\n                               Cell.apply<B, (c : C) => (d : D) => (e : E) => (f : F) => G>(cf, b),\r\n                               c),\r\n                           d),\r\n                       e),\r\n                   f,\r\n                   toSources(Lambda6_deps(fn0)));\r\n    }\r\n\r\n    /**\r\n     * High order depenency traking. If any newly created sodium objects within a value of a cell of a sodium object\r\n     * happen to accumulate state, this method will keep the accumulation of state up to date.\r\n     */\r\n    public tracking(extractor: (a: A) => (Stream<any>|Cell<any>)[]) : Cell<A> {\r\n        const out = new StreamWithSend<A>(null);\r\n        let vertex = new Vertex(\"tracking\", 0, [\r\n            new Source(\r\n                this.vertex,\r\n                () => {\r\n                    let cleanup2: ()=>void = () => {};\r\n                    let updateDeps =\r\n                        (a: A) => {\r\n                            let lastCleanups2 = cleanup2;\r\n                            let deps = extractor(a).map(dep => dep.getVertex__());\r\n                            for (let i = 0; i < deps.length; ++i) {\r\n                                let dep = deps[i];\r\n                                vertex.childrn.push(dep);\r\n                                dep.increment(Vertex.NULL);\r\n                            }\r\n                            cleanup2 = () => {\r\n                                for (let i = 0; i < deps.length; ++i) {\r\n                                    let dep = deps[i];\r\n                                    for (let j = 0; j < vertex.childrn.length; ++j) {\r\n                                        if (vertex.childrn[j] === dep) {\r\n                                            vertex.childrn.splice(j, 1);\r\n                                            break;\r\n                                        }\r\n                                    }\r\n                                    dep.decrement(Vertex.NULL);\r\n                                }\r\n                            };\r\n                            lastCleanups2();\r\n                        };\r\n                    updateDeps(this.sample());\r\n                    var cleanup1 =\r\n                        Operational.updates(this).listen_(\r\n                            vertex,\r\n                            (a: A) => {\r\n                                updateDeps(a);\r\n                                out.send_(a);\r\n                            },\r\n                            false\r\n                        );\r\n                    return () => {\r\n                        cleanup1();\r\n                        cleanup2();\r\n                    }\r\n                }\r\n            )\r\n        ]);\r\n        out.setVertex__(vertex);\r\n        return out.holdLazy(this.sampleLazy());\r\n    }\r\n\r\n    /**\r\n     * Lift an array of cells into a cell of an array.\r\n     */\r\n    public static liftArray<A>(ca : Cell<A>[]) : Cell<A[]> {\r\n        return Cell._liftArray(ca, 0, ca.length);\r\n    }\r\n\r\n    private static _liftArray<A>(ca : Cell<A>[], fromInc: number, toExc: number) : Cell<A[]> {\r\n        if (toExc - fromInc == 0) {\r\n            return new Cell<A[]>([]);\r\n        } else if (toExc - fromInc == 1) {\r\n            return ca[fromInc].map(a => [a]);\r\n        } else {\r\n            let pivot = Math.floor((fromInc + toExc) / 2);\r\n            // the thunk boxing/unboxing here is a performance hack for lift when there are simutaneous changing cells.\r\n            return Cell._liftArray(ca, fromInc, pivot).lift(\r\n                    Cell._liftArray(ca, pivot, toExc),\r\n                    (array1, array2) => () => array1.concat(array2)\r\n                )\r\n                .map(x => x());\r\n        }\r\n    }\r\n\r\n\t/**\r\n\t * Apply a value inside a cell to a function inside a cell. This is the\r\n\t * primitive for all function lifting.\r\n\t */\r\n\tstatic apply<A,B>(cf : Cell<(a : A) => B>, ca : Cell<A>, sources? : Source[]) : Cell<B> {\r\n    \treturn Transaction.run(() => {\r\n            let pumping = false;\r\n    \t    const state = new ApplyState<A,B>(),\r\n                out = new StreamWithSend<B>(),\r\n                cf_updates = Operational.updates(cf),\r\n                ca_updates = Operational.updates(ca),\r\n                pump = () => {\r\n                    if (pumping) {\r\n                        return;\r\n                    }\r\n                    pumping = true;\r\n                    Transaction.currentTransaction.prioritized(out.getVertex__(), () => {\r\n                        let f = state.f_present ? state.f : cf.sampleNoTrans__();\r\n                        let a = state.a_present ? state.a : ca.sampleNoTrans__();\r\n                        out.send_(f(a));\r\n                        pumping = false;\r\n                    });\r\n                },\r\n                src1 = new Source(\r\n                        cf_updates.getVertex__(),\r\n                        () => {\r\n                            return cf_updates.listen_(out.getVertex__(), (f : (a : A) => B) => {\r\n                                state.f = f;\r\n                                state.f_present = true;\r\n                                pump();\r\n                            }, false);\r\n                        }\r\n                    ),\r\n                src2 = new Source(\r\n                        ca_updates.getVertex__(),\r\n                        () => {\r\n                            return ca_updates.listen_(out.getVertex__(), (a : A) => {\r\n                                state.a = a;\r\n                                state.a_present = true;\r\n                                pump();\r\n                            }, false);\r\n                        }\r\n                    );\r\n            out.setVertex__(new Vertex(\"apply\", 0,\r\n                [src1, src2].concat(sources ? sources : [])\r\n            ));\r\n            return out.holdLazy(new Lazy<B>(() =>\r\n                    cf.sampleNoTrans__()(ca.sampleNoTrans__())\r\n                ));\r\n        });\r\n\t}\r\n\r\n\t/**\r\n\t * Unwrap a cell inside another cell to give a time-varying cell implementation.\r\n\t */\r\n    static switchC<A>(cca : Cell<Cell<A>>) : Cell<A> {\r\n\t    return Transaction.run(() => {\r\n            const za = cca.sampleLazy().map((ba : Cell<A>) => ba.sample()),\r\n                out = new StreamWithSend<A>();\r\n            let outValue: A = null;\r\n            let pumping = false;\r\n            const pump = () => {\r\n                if (pumping) {\r\n                    return;\r\n                }\r\n                pumping = true;\r\n                Transaction.currentTransaction.prioritized(out.getVertex__(), () => {\r\n                    out.send_(outValue);\r\n                    outValue = null;\r\n                    pumping = false;\r\n                });\r\n            };\r\n            let last_ca : Cell<A> = null;\r\n            const cca_value = Operational.value(cca),\r\n                  src = new Source(\r\n                        cca_value.getVertex__(),\r\n                        () => {\r\n                            let kill2 : () => void = last_ca === null ? null :\r\n                                    Operational.value(last_ca).listen_(out.getVertex__(),\r\n                                        (a : A) => { outValue = a; pump(); }, false);\r\n                            const kill1 = cca_value.listen_(out.getVertex__(), (ca : Cell<A>) => {\r\n                                last_ca = ca;\r\n                                // Connect before disconnect to avoid memory bounce, when switching to same cell twice.\r\n                                let nextKill2 = Operational.value(ca).listen_(out.getVertex__(),\r\n                                    (a : A) => {\r\n                                        outValue = a;\r\n                                        pump();\r\n                                    },\r\n                                    false);\r\n                                if (kill2 !== null)\r\n                                    kill2();\r\n                                kill2 = nextKill2;\r\n                            }, false);\r\n                            return () => { kill1(); kill2(); };\r\n                        }\r\n                    );\r\n            out.setVertex__(new Vertex(\"switchC\", 0, [src]));\r\n            return out.holdLazy(za);\r\n        });\r\n\t}\r\n\r\n\t/**\r\n\t * Unwrap a stream inside a cell to give a time-varying stream implementation.\r\n\t */\r\n\tstatic switchS<A>(csa : Cell<Stream<A>>) : Stream<A> {\r\n\t    return Transaction.run(() => {\r\n            const out = new StreamWithSend<A>(),\r\n                  h2 = (a : A) => {\r\n                          out.send_(a);\r\n                      },\r\n                  src = new Source(\r\n                      csa.getVertex__(),\r\n                      () => {\r\n                          let kill2 = csa.sampleNoTrans__().listen_(out.getVertex__(), h2, false);\r\n                          const kill1 = csa.getStream__().listen_(out.getVertex__(), (sa : Stream<A>) => {\r\n                              // Connect before disconnect to avoid memory bounce, when switching to same stream twice.\r\n                              let nextKill2 = sa.listen_(out.getVertex__(), h2, true);\r\n                              kill2();\r\n                              kill2 = nextKill2;\r\n                          }, false);\r\n                          return () => { kill1(); kill2(); };\r\n                      }\r\n                  );\r\n\t        out.setVertex__(new Vertex(\"switchS\", 0, [src]));\r\n\t        return out;\r\n\t    });\r\n    }\r\n\r\n    /**\r\n     * When transforming a value from a larger type to a smaller type, it is likely for duplicate changes to become\r\n     * propergated. This function insures only distinct changes get propergated.\r\n     */\r\n    calm(eq: (a:A,b:A)=>boolean): Cell<A> {\r\n        return Operational\r\n            .updates(this)\r\n            .collectLazy(\r\n                this.sampleLazy(),\r\n                (newValue, oldValue) => {\r\n                    let result: A;\r\n                    if (eq(newValue, oldValue)) {\r\n                        result = null;\r\n                    } else {\r\n                        result = newValue;\r\n                    }\r\n                    return new Tuple2(result, newValue);\r\n                }\r\n            )\r\n            .filterNotNull()\r\n            .holdLazy(this.sampleLazy());\r\n    }\r\n\r\n    /**\r\n     * This function is the same as calm, except you do not need to pass an eq function. This function will use (===)\r\n     * as its eq function. I.E. calling calmRefEq() is the same as calm((a,b) => a === b).\r\n     */\r\n    calmRefEq(): Cell<A> {\r\n        return this.calm((a, b) => a === b);\r\n    }\r\n\r\n\t/**\r\n\t * Listen for updates to the value of this cell. This is the observer pattern. The\r\n\t * returned {@link Listener} has a {@link Listener#unlisten()} method to cause the\r\n\t * listener to be removed. This is an OPERATIONAL mechanism is for interfacing between\r\n\t * the world of I/O and for FRP.\r\n\t * @param h The handler to execute when there's a new value.\r\n\t *   You should make no assumptions about what thread you are called on, and the\r\n\t *   handler should not block. You are not allowed to use {@link CellSink#send(Object)}\r\n\t *   or {@link StreamSink#send(Object)} in the handler.\r\n\t *   An exception will be thrown, because you are not meant to use this to create\r\n\t *   your own primitives.\r\n     */\r\n    listen(h : (a : A) => void) : () => void {\r\n        return Transaction.run(() => {\r\n            return Operational.value(this).listen(h);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Fantasy-land Algebraic Data Type Compatability.\r\n     * Cell satisfies the Functor, Apply, Applicative categories\r\n     * @see {@link https://github.com/fantasyland/fantasy-land} for more info\r\n     */\r\n\r\n    //of :: Applicative f => a -> f a\r\n    static 'fantasy-land/of'<A>(a:A):Cell<A> {\r\n      return new Cell<A>(a);\r\n    }\r\n\r\n    //map :: Functor f => f a ~> (a -> b) -> f b\r\n    'fantasy-land/map'<B>(f : ((a : A) => B)) : Cell<B> {\r\n      return this.map(f);\r\n    }\r\n\r\n    //ap :: Apply f => f a ~> f (a -> b) -> f b\r\n    'fantasy-land/ap'<B>(cf: Cell<(a : A) => B>):Cell<B> {\r\n        return Cell.apply(cf, this);\r\n    }\r\n}\r\n", "import { Source, Vertex } from \"./Vertex\";\r\n\r\nexport class Listener<A> {\r\n    constructor(h : (a : A) => void, target : Vertex) {\r\n        this.h = h;\r\n        this.target = target;\r\n    }\r\n    h : (a : A) => void;\r\n    target : Vertex;\r\n}\r\n", "import { Lazy } from \"./Lazy\";\r\nimport { Cell } from \"./Cell\";\r\nimport { Stream } from \"./Stream\";\r\nimport { Transaction } from \"./Transaction\";\r\n\r\nexport class LazyCell<A> extends Cell<A> {\r\n    constructor(lazyInitValue : Lazy<A>, str? : Stream<A>) {\r\n        super(null, null);\r\n        Transaction.run(() => {\r\n            if (str)\r\n                this.setStream(str);\r\n            this.lazyInitValue = lazyInitValue;\r\n        });\r\n    }\r\n\r\n    sampleNoTrans__() : A {  // Override\r\n        if (this.value == null && this.lazyInitValue != null) {\r\n            this.value = this.lazyInitValue.get();\r\n            this.lazyInitValue = null;\r\n        }\r\n        return this.value;\r\n    }\r\n}\r\n", "import { Lambda1, Lambda1_deps, Lambda1_toFunction,\r\n         Lambda2, Lambda2_deps, Lambda2_toFunction,\r\n         Lambda3, Lambda3_deps, Lambda3_toFunction,\r\n         Lambda4, Lambda4_deps, Lambda4_toFunction,\r\n         Lambda5, Lambda5_deps, Lambda5_toFunction,\r\n         Lambda6, Lambda6_deps, Lambda6_toFunction,\r\n         toSources } from \"./Lambda\";\r\nimport { Source, Vertex } from \"./Vertex\";\r\nimport { Transaction } from \"./Transaction\";\r\nimport { CoalesceHandler } from \"./CoalesceHandler\";\r\nimport { Cell } from \"./Cell\";\r\n//import { StreamLoop } from \"./StreamLoop\";\r\nimport { Listener } from \"./Listener\";\r\nimport { Tuple2 } from \"./Tuple2\";\r\nimport { Lazy } from \"./Lazy\";\r\nimport { LazyCell } from \"./LazyCell\";\r\nimport * as Z from \"sanctuary-type-classes\";\r\n\r\nclass MergeState<A> {\r\n    constructor() {}\r\n    left : A = null;\r\n    left_present : boolean = false;\r\n    right : A = null;\r\n    right_present : boolean = false;\r\n}\r\n\r\nexport class Stream<A> {\r\n    constructor(vertex? : Vertex) {\r\n        this.vertex = vertex ? vertex : new Vertex(\"Stream\", 0, []);\r\n    }\r\n\r\n    getVertex__() : Vertex {\r\n        return this.vertex;\r\n    }\r\n\r\n    protected vertex : Vertex;\r\n    protected listeners : Array<Listener<A>> = [];\r\n    protected firings : A[] = [];\r\n\r\n    /**\r\n     * Transform the stream's event values according to the supplied function, so the returned\r\n     * Stream's event values reflect the value of the function applied to the input\r\n     * Stream's event values.\r\n     * @param f Function to apply to convert the values. It may construct FRP logic or use\r\n     *    {@link Cell#sample()} in which case it is equivalent to {@link Stream#snapshot(Cell)}ing the\r\n     *    cell. Apart from this the function must be <em>referentially transparent</em>.\r\n     */\r\n    map<B>(f : ((a : A) => B) | Lambda1<A,B>) : Stream<B> {\r\n        const out = new StreamWithSend<B>(null);\r\n        const ff = Lambda1_toFunction(f);\r\n        out.vertex = new Vertex(\"map\", 0, [\r\n                new Source(\r\n                    this.vertex,\r\n                    () => {\r\n                        return this.listen_(out.vertex, (a : A) => {\r\n                            out.send_(ff(a));\r\n                        }, false);\r\n                    }\r\n                )\r\n            ].concat(toSources(Lambda1_deps(f)))\r\n        );\r\n        return out;\r\n    }\r\n\r\n    /**\r\n     * Transform the stream's event values into the specified constant value.\r\n     * @param b Constant value.\r\n     */\r\n    mapTo<B>(b : B) : Stream<B> {\r\n        const out = new StreamWithSend<B>(null);\r\n        out.vertex = new Vertex(\"mapTo\", 0, [\r\n                new Source(\r\n                    this.vertex,\r\n                    () => {\r\n                        return this.listen_(out.vertex, (a : A) => {\r\n                            out.send_(b);\r\n                        }, false);\r\n                    }\r\n                )\r\n            ]\r\n        );\r\n        return out;\r\n    }\r\n\r\n    /**\r\n     * Variant of {@link Stream#merge(Stream, Lambda2)} that merges two streams and will drop an event\r\n     * in the simultaneous case.\r\n     * <p>\r\n     * In the case where two events are simultaneous (i.e. both\r\n     * within the same transaction), the event from <em>this</em> will take precedence, and\r\n     * the event from <em>s</em> will be dropped.\r\n     * If you want to specify your own combining function, use {@link Stream#merge(Stream, Lambda2)}.\r\n     * s1.orElse(s2) is equivalent to s1.merge(s2, (l, r) -&gt; l).\r\n     * <p>\r\n     * The name orElse() is used instead of merge() to make it really clear that care should\r\n     * be taken, because events can be dropped.\r\n     */\r\n    orElse(s : Stream<A>) : Stream<A> {\r\n        return this.merge(s, (left : A, right: A) => {\r\n            return left;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Merge two streams of the same type into one, so that events on either input appear\r\n     * on the returned stream.\r\n     * <p>\r\n     * If the events are simultaneous (that is, one event from this and one from <em>s</em>\r\n     * occurring in the same transaction), combine them into one using the specified combining function\r\n     * so that the returned stream is guaranteed only ever to have one event per transaction.\r\n     * The event from <em>this</em> will appear at the left input of the combining function, and\r\n     * the event from <em>s</em> will appear at the right.\r\n     * @param f Function to combine the values. It may construct FRP logic or use\r\n     *    {@link Cell#sample()}. Apart from this the function must be <em>referentially transparent</em>.\r\n     */\r\n    merge(s : Stream<A>, f : ((left : A, right : A) => A) | Lambda2<A,A,A>) : Stream<A> {\r\n        const ff = Lambda2_toFunction(f);\r\n        const mergeState = new MergeState<A>();\r\n        let pumping = false;\r\n        const out = new StreamWithSend<A>(null);\r\n        const pump = () => {\r\n            if (pumping) {\r\n                return;\r\n            }\r\n            pumping = true;\r\n            Transaction.currentTransaction.prioritized(out.getVertex__(), () => {\r\n                if (mergeState.left_present && mergeState.right_present) {\r\n                    out.send_(ff(mergeState.left, mergeState.right));\r\n                } else if (mergeState.left_present) {\r\n                    out.send_(mergeState.left);\r\n                } else if (mergeState.right_present) {\r\n                    out.send_(mergeState.right);\r\n                }\r\n                mergeState.left = null;\r\n                mergeState.left_present = false;\r\n                mergeState.right = null;\r\n                mergeState.right_present = false;\r\n                pumping = false;\r\n            });\r\n        };\r\n        const vertex = new Vertex(\"merge\", 0,\r\n            [\r\n                new Source(\r\n                    this.vertex,\r\n                    () => this.listen_(out.vertex, (a : A) => {\r\n                        mergeState.left = a;\r\n                        mergeState.left_present = true;\r\n                        pump();\r\n                    }, false)\r\n                ),\r\n                new Source(\r\n                    s.vertex,\r\n                    () => s.listen_(out.vertex, (a : A) => {\r\n                        mergeState.right = a;\r\n                        mergeState.right_present = true;\r\n                        pump();\r\n                    }, false)\r\n                )\r\n            ].concat(toSources(Lambda2_deps(f)))\r\n        );\r\n        out.vertex = vertex;\r\n        return out;\r\n    }\r\n\r\n    /**\r\n     * Return a stream that only outputs events for which the predicate returns true.\r\n     */\r\n    filter(f : ((a : A) => boolean) | Lambda1<A,boolean>) : Stream<A> {\r\n        const out = new StreamWithSend<A>(null);\r\n        const ff = Lambda1_toFunction(f);\r\n        out.vertex = new Vertex(\"filter\", 0, [\r\n                new Source(\r\n                    this.vertex,\r\n                    () => {\r\n                        return this.listen_(out.vertex, (a : A) => {\r\n                            if (ff(a))\r\n                                out.send_(a);\r\n                        }, false);\r\n                    }\r\n                )\r\n            ].concat(toSources(Lambda1_deps(f)))\r\n        );\r\n        return out;\r\n    }\r\n\r\n    /**\r\n     * Return a stream that only outputs events that have present\r\n     * values, discarding null values.\r\n     */\r\n    filterNotNull() : Stream<A> {\r\n        const out = new StreamWithSend<A>(null);\r\n        out.vertex = new Vertex(\"filterNotNull\", 0, [\r\n                new Source(\r\n                    this.vertex,\r\n                    () => {\r\n                        return this.listen_(out.vertex, (a : A) => {\r\n                            if (a !== null)\r\n                                out.send_(a);\r\n                        }, false);\r\n                    }\r\n                )\r\n            ]\r\n        );\r\n        return out;\r\n    }\r\n\r\n    /**\r\n     * Return a stream that only outputs events from the input stream\r\n     * when the specified cell's value is true.\r\n     */\r\n    gate(c : Cell<boolean>) : Stream<A> {\r\n        return this.snapshot(c, (a : A, pred : boolean) => {\r\n            return pred ? a : null;\r\n        }).filterNotNull();\r\n    }\r\n\r\n\t/**\r\n\t * Variant of {@link snapshot(Cell, Lambda2)} that captures the cell's value\r\n\t * at the time of the event firing, ignoring the stream's value.\r\n\t */\r\n\tsnapshot1<B>(c : Cell<B>) : Stream<B> {\r\n        const out = new StreamWithSend<B>(null);\r\n        out.vertex = new Vertex(\"snapshot1\", 0, [\r\n                new Source(\r\n                    this.vertex,\r\n                    () => {\r\n                        return this.listen_(out.vertex, (a : A) => {\r\n                            out.send_(c.sampleNoTrans__());\r\n                        }, false);\r\n                    }\r\n                ),\r\n                new Source(c.getVertex__(), null)\r\n            ]\r\n        );\r\n        return out;\r\n\t}\r\n\r\n\t/**\r\n\t * Return a stream whose events are the result of the combination using the specified\r\n\t * function of the input stream's event value and the value of the cell at that time.\r\n     * <P>\r\n     * There is an implicit delay: State updates caused by event firings being held with\r\n     * {@link Stream#hold(Object)} don't become visible as the cell's current value until\r\n     * the following transaction. To put this another way, {@link Stream#snapshot(Cell, Lambda2)}\r\n     * always sees the value of a cell as it was before any state changes from the current\r\n     * transaction.\r\n     */\r\n\tsnapshot<B,C>(b : Cell<B>, f_ : ((a : A, b : B) => C) | Lambda2<A,B,C>) : Stream<C>\r\n\t{\r\n        const out = new StreamWithSend<C>(null);\r\n        const ff = Lambda2_toFunction(f_);\r\n        out.vertex = new Vertex(\"snapshot\", 0, [\r\n                new Source(\r\n                    this.vertex,\r\n                    () => {\r\n                        return this.listen_(out.vertex, (a : A) => {\r\n                            out.send_(ff(a, b.sampleNoTrans__()));\r\n                        }, false);\r\n                    }\r\n                ),\r\n                new Source(b.getVertex__(), null)\r\n            ].concat(toSources(Lambda2_deps(f_)))\r\n        );\r\n        return out;\r\n\t}\r\n\r\n\t/**\r\n\t * Return a stream whose events are the result of the combination using the specified\r\n\t * function of the input stream's event value and the value of the cells at that time.\r\n     * <P>\r\n     * There is an implicit delay: State updates caused by event firings being held with\r\n     * {@link Stream#hold(Object)} don't become visible as the cell's current value until\r\n     * the following transaction. To put this another way, snapshot()\r\n     * always sees the value of a cell as it was before any state changes from the current\r\n     * transaction.\r\n     */\r\n\tsnapshot3<B,C,D>(b : Cell<B>, c : Cell<C>, f_ : ((a : A, b : B, c : C) => D) | Lambda3<A,B,C,D>) : Stream<D>\r\n\t{\r\n        const out = new StreamWithSend<D>(null);\r\n        const ff = Lambda3_toFunction(f_);\r\n        out.vertex = new Vertex(\"snapshot\", 0, [\r\n                new Source(\r\n                    this.vertex,\r\n                    () => {\r\n                        return this.listen_(out.vertex, (a : A) => {\r\n                            out.send_(ff(a, b.sampleNoTrans__(), c.sampleNoTrans__()));\r\n                        }, false);\r\n                    }\r\n                ),\r\n                new Source(b.getVertex__(), null),\r\n                new Source(c.getVertex__(), null)\r\n            ].concat(toSources(Lambda3_deps(f_)))\r\n        );\r\n        return out;\r\n\t}\r\n\r\n\t/**\r\n\t * Return a stream whose events are the result of the combination using the specified\r\n\t * function of the input stream's event value and the value of the cells at that time.\r\n     * <P>\r\n     * There is an implicit delay: State updates caused by event firings being held with\r\n     * {@link Stream#hold(Object)} don't become visible as the cell's current value until\r\n     * the following transaction. To put this another way, snapshot()\r\n     * always sees the value of a cell as it was before any state changes from the current\r\n     * transaction.\r\n     */\r\n\tsnapshot4<B,C,D,E>(b : Cell<B>, c : Cell<C>, d : Cell<D>,\r\n\t    f_ : ((a : A, b : B, c : C, d : D) => E) | Lambda4<A,B,C,D,E>) : Stream<E>\r\n\t{\r\n        const out = new StreamWithSend<E>(null);\r\n        const ff = Lambda4_toFunction(f_);\r\n        out.vertex = new Vertex(\"snapshot\", 0, [\r\n                new Source(\r\n                    this.vertex,\r\n                    () => {\r\n                        return this.listen_(out.vertex, (a : A) => {\r\n                            out.send_(ff(a, b.sampleNoTrans__(), c.sampleNoTrans__(),\r\n                                            d.sampleNoTrans__()));\r\n                        }, false);\r\n                    }\r\n                ),\r\n                new Source(b.getVertex__(), null),\r\n                new Source(c.getVertex__(), null),\r\n                new Source(d.getVertex__(), null)\r\n            ].concat(toSources(Lambda4_deps(f_)))\r\n        );\r\n        return out;\r\n\t}\r\n\r\n\t/**\r\n\t * Return a stream whose events are the result of the combination using the specified\r\n\t * function of the input stream's event value and the value of the cells at that time.\r\n     * <P>\r\n     * There is an implicit delay: State updates caused by event firings being held with\r\n     * {@link Stream#hold(Object)} don't become visible as the cell's current value until\r\n     * the following transaction. To put this another way, snapshot()\r\n     * always sees the value of a cell as it was before any state changes from the current\r\n     * transaction.\r\n     */\r\n\tsnapshot5<B,C,D,E,F>(b : Cell<B>, c : Cell<C>, d : Cell<D>, e : Cell<E>,\r\n\t    f_ : ((a : A, b : B, c : C, d : D, e : E) => F) | Lambda5<A,B,C,D,E,F>) : Stream<F>\r\n\t{\r\n        const out = new StreamWithSend<F>(null);\r\n        const ff = Lambda5_toFunction(f_);\r\n        out.vertex = new Vertex(\"snapshot\", 0, [\r\n                new Source(\r\n                    this.vertex,\r\n                    () => {\r\n                        return this.listen_(out.vertex, (a : A) => {\r\n                            out.send_(ff(a, b.sampleNoTrans__(), c.sampleNoTrans__(),\r\n                                            d.sampleNoTrans__(), e.sampleNoTrans__()));\r\n                        }, false);\r\n                    }\r\n                ),\r\n                new Source(b.getVertex__(), null),\r\n                new Source(c.getVertex__(), null),\r\n                new Source(d.getVertex__(), null),\r\n                new Source(e.getVertex__(), null)\r\n            ].concat(toSources(Lambda5_deps(f_)))\r\n        );\r\n        return out;\r\n\t}\r\n\r\n\t/**\r\n\t * Return a stream whose events are the result of the combination using the specified\r\n\t * function of the input stream's event value and the value of the cells at that time.\r\n     * <P>\r\n     * There is an implicit delay: State updates caused by event firings being held with\r\n     * {@link Stream#hold(Object)} don't become visible as the cell's current value until\r\n     * the following transaction. To put this another way, snapshot()\r\n     * always sees the value of a cell as it was before any state changes from the current\r\n     * transaction.\r\n     */\r\n\tsnapshot6<B,C,D,E,F,G>(b : Cell<B>, c : Cell<C>, d : Cell<D>, e : Cell<E>, f : Cell<F>,\r\n\t    f_ : ((a : A, b : B, c : C, d : D, e : E, f : F) => G) | Lambda6<A,B,C,D,E,F,G>) : Stream<G>\r\n\t{\r\n        const out = new StreamWithSend<G>(null);\r\n        const ff = Lambda6_toFunction(f_);\r\n        out.vertex = new Vertex(\"snapshot\", 0, [\r\n                new Source(\r\n                    this.vertex,\r\n                    () => {\r\n                        return this.listen_(out.vertex, (a : A) => {\r\n                            out.send_(ff(a, b.sampleNoTrans__(), c.sampleNoTrans__(),\r\n                                            d.sampleNoTrans__(), e.sampleNoTrans__(),\r\n                                            f.sampleNoTrans__()));\r\n                        }, false);\r\n                    }\r\n                ),\r\n                new Source(b.getVertex__(), null),\r\n                new Source(c.getVertex__(), null),\r\n                new Source(d.getVertex__(), null),\r\n                new Source(e.getVertex__(), null),\r\n                new Source(f.getVertex__(), null)\r\n            ].concat(toSources(Lambda6_deps(f_)))\r\n        );\r\n        return out;\r\n\t}\r\n\r\n\t/**\r\n\t * Create a {@link Cell} with the specified initial value, that is updated\r\n     * by this stream's event values.\r\n     * <p>\r\n     * There is an implicit delay: State updates caused by event firings don't become\r\n     * visible as the cell's current value as viewed by {@link Stream#snapshot(Cell, Lambda2)}\r\n     * until the following transaction. To put this another way,\r\n     * {@link Stream#snapshot(Cell, Lambda2)} always sees the value of a cell as it was before\r\n     * any state changes from the current transaction.\r\n     */\r\n    hold(initValue : A) : Cell<A> {\r\n        return new Cell<A>(initValue, this);\r\n\t}\r\n\r\n\t/**\r\n\t * A variant of {@link hold(Object)} with an initial value captured by {@link Cell#sampleLazy()}.\r\n\t */\r\n\tholdLazy(initValue : Lazy<A>) : Cell<A> {\r\n\t    return new LazyCell<A>(initValue, this);\r\n\t}\r\n\r\n    /**\r\n     * Transform an event with a generalized state loop (a Mealy machine). The function\r\n     * is passed the input and the old state and returns the new state and output value.\r\n     * @param f Function to apply to update the state. It may construct FRP logic or use\r\n     *    {@link Cell#sample()} in which case it is equivalent to {@link Stream#snapshot(Cell)}ing the\r\n     *    cell. Apart from this the function must be <em>referentially transparent</em>.\r\n     */\r\n    collect<B,S>(initState : S, f : ((a : A, s : S) => Tuple2<B,S>) | Lambda2<A,S,Tuple2<B,S>>) : Stream<B> {\r\n        return this.collectLazy(new Lazy<S>(() => { return initState; }), f);\r\n    }\r\n\r\n    /**\r\n     * A variant of {@link collect(Object, Lambda2)} that takes an initial state returned by\r\n     * {@link Cell#sampleLazy()}.\r\n     */\r\n    collectLazy<B,S>(initState : Lazy<S>, f : ((a : A, s : S) => Tuple2<B,S>) | Lambda2<A,S,Tuple2<B,S>>) : Stream<B> {\r\n        const ea = this;\r\n        return Transaction.run(() => {\r\n            const es = new StreamLoop<S>(),\r\n                s = es.holdLazy(initState),\r\n                ebs = ea.snapshot(s, f),\r\n                eb = ebs.map((bs : Tuple2<B,S>) => { return bs.a; }),\r\n                es_out = ebs.map((bs : Tuple2<B,S>) => { return bs.b; });\r\n            es.loop(es_out);\r\n            return eb;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Accumulate on input event, outputting the new state each time.\r\n     * @param f Function to apply to update the state. It may construct FRP logic or use\r\n     *    {@link Cell#sample()} in which case it is equivalent to {@link Stream#snapshot(Cell)}ing the\r\n     *    cell. Apart from this the function must be <em>referentially transparent</em>.\r\n     */\r\n    accum<S>(initState : S, f : ((a : A, s : S) => S) | Lambda2<A,S,S>) : Cell<S> {\r\n        return this.accumLazy(new Lazy<S>(() => { return initState; }), f);\r\n    }\r\n\r\n    /**\r\n     * A variant of {@link accum(Object, Lambda2)} that takes an initial state returned by\r\n     * {@link Cell#sampleLazy()}.\r\n     */\r\n    accumLazy<S>(initState : Lazy<S>, f : ((a : A, s : S) => S) | Lambda2<A,S,S>) : Cell<S> {\r\n        const ea = this;\r\n        return Transaction.run(() => {\r\n            const es = new StreamLoop<S>(),\r\n                s = es.holdLazy(initState),\r\n                es_out = ea.snapshot(s, f);\r\n            es.loop(es_out);\r\n            return es_out.holdLazy(initState);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Return a stream that outputs only one value: the next event of the\r\n     * input stream, starting from the transaction in which once() was invoked.\r\n     */\r\n    once() : Stream<A> {\r\n    /*\r\n        return Transaction.run(() => {\r\n            const ev = this,\r\n                out = new StreamWithSend<A>();\r\n            let la : () => void = null;\r\n            la = ev.listen_(out.vertex, (a : A) => {\r\n                if (la !== null) {\r\n                    out.send_(a);\r\n                    la();\r\n                    la = null;\r\n                }\r\n            }, false);\r\n            return out;\r\n        });\r\n        */\r\n        // We can't use the implementation above, beacuse deregistering\r\n        // listeners triggers the exception\r\n        // \"send() was invoked before listeners were registered\"\r\n        // We can revisit this another time. For now we will use the less\r\n        // efficient implementation below.\r\n        const me = this;\r\n        return Transaction.run(() => me.gate(me.mapTo(false).hold(true)));\r\n    }\r\n\r\n    listen(h : (a : A) => void) : () => void {\r\n        return Transaction.run<() => void>(() => {\r\n            return this.listen_(Vertex.NULL, h, false);\r\n        });\r\n    }\r\n\r\n    listen_(target : Vertex,\r\n            h : (a : A) => void,\r\n            suppressEarlierFirings : boolean) : () => void {\r\n        if (this.vertex.register(target))\r\n            Transaction.currentTransaction.requestRegen();\r\n        const listener = new Listener<A>(h, target);\r\n        this.listeners.push(listener);\r\n        if (!suppressEarlierFirings && this.firings.length != 0) {\r\n            const firings = this.firings.slice();\r\n            Transaction.currentTransaction.prioritized(target, () => {\r\n                // Anything sent already in this transaction must be sent now so that\r\n                // there's no order dependency between send and listen.\r\n                for (let i = 0; i < firings.length; i++)\r\n                    h(firings[i]);\r\n            });\r\n        }\r\n        return () => {\r\n            let removed = false;\r\n            for (let i = 0; i < this.listeners.length; i++) {\r\n                if (this.listeners[i] == listener) {\r\n                    this.listeners.splice(i, 1);\r\n                    removed = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (removed)\r\n                this.vertex.deregister(target);\r\n        };\r\n    }\r\n\r\n\r\n    /**\r\n     * Fantasy-land Algebraic Data Type Compatability.\r\n     * Stream satisfies the Functor and Monoid Categories (and hence Semigroup)\r\n     * @see {@link https://github.com/fantasyland/fantasy-land} for more info\r\n     */\r\n\r\n    //map :: Functor f => f a ~> (a -> b) -> f b\r\n    'fantasy-land/map'<B>(f : ((a : A) => B)) : Stream<B> {\r\n      return this.map(f);\r\n    }\r\n\r\n    //concat :: Semigroup a => a ~> a -> a\r\n    'fantasy-land/concat'(a:Stream<A>) : Stream<A> {\r\n      return this.merge(a, (left:any, right) => {\r\n        return (Z.Semigroup.test(left)) ? Z.concat(left, right) : left;\r\n      });\r\n    }\r\n\r\n    //empty :: Monoid m => () -> m\r\n    'fantasy-land/empty'() : Stream<A> {\r\n      return new Stream<A>();\r\n    }\r\n}\r\n\r\nexport class StreamWithSend<A> extends Stream<A> {\r\n    constructor(vertex? : Vertex) {\r\n        super(vertex);\r\n    }\r\n\r\n    setVertex__(vertex : Vertex) {  // TO DO figure out how to hide this\r\n        this.vertex = vertex;\r\n    }\r\n\r\n    send_(a : A) : void {\r\n\t\tif (this.firings.length == 0)\r\n\t\t\tTransaction.currentTransaction.last(() => {\r\n\t\t\t    this.firings = [];\r\n            });\r\n\t\tthis.firings.push(a);\r\n\t\tconst listeners = this.listeners.slice();\r\n        for (let i = 0; i < listeners.length; i++) {\r\n            const h = listeners[i].h;\r\n            Transaction.currentTransaction.prioritized(listeners[i].target, () => {\r\n                Transaction.currentTransaction.inCallback++;\r\n                try {\r\n                    h(a);\r\n                    Transaction.currentTransaction.inCallback--;\r\n                }\r\n                catch (err) {\r\n                    Transaction.currentTransaction.inCallback--;\r\n                    throw err;\r\n                }\r\n            });\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * A forward reference for a {@link Stream} equivalent to the Stream that is referenced.\r\n */\r\nexport class StreamLoop<A> extends StreamWithSend<A> {\r\n    assigned__ : boolean = false;  // to do: Figure out how to hide this\r\n\r\n    constructor()\r\n    {\r\n        super();\r\n        this.vertex.name = \"StreamLoop\";\r\n    \tif (Transaction.currentTransaction === null)\r\n    \t    throw new Error(\"StreamLoop/CellLoop must be used within an explicit transaction\");\r\n    }\r\n\r\n    /**\r\n     * Resolve the loop to specify what the StreamLoop was a forward reference to. It\r\n     * must be invoked inside the same transaction as the place where the StreamLoop is used.\r\n     * This requires you to create an explicit transaction with {@link Transaction#run(Lambda0)}\r\n     * or {@link Transaction#runVoid(Runnable)}.\r\n     */\r\n    loop(sa_out : Stream<A>) : void {\r\n        if (this.assigned__)\r\n            throw new Error(\"StreamLoop looped more than once\");\r\n        this.assigned__ = true;\r\n        this.vertex.addSource(\r\n            new Source(\r\n                sa_out.getVertex__(),\r\n                () => {\r\n                    return sa_out.listen_(this.vertex, (a : A) => {\r\n                        this.send_(a);\r\n                    }, false);\r\n                }\r\n            )\r\n        );\r\n    }\r\n}\r\n", "import { Lambda1, Lambda1_deps, Lambda1_toFunction,\r\n         Lambda2, Lambda2_deps, Lambda2_toFunction,\r\n         toSources } from \"./Lambda\";\r\nimport { Transaction } from \"./Transaction\";\r\nimport { StreamWithSend } from \"./Stream\";\r\nimport { Vertex } from \"./Vertex\";\r\n\r\nexport class CoalesceHandler<A>\r\n{\r\n\tconstructor(f : ((l : A, r : A) => A) | Lambda2<A,A,A>, out : StreamWithSend<A>)\r\n\t{\r\n\t    this.f = Lambda2_toFunction(f);\r\n\t    this.out = out;\r\n        this.out.getVertex__().sources = this.out.getVertex__().sources.concat(\r\n            toSources(Lambda2_deps(f)));\r\n        this.accumValid = false;\r\n    }\r\n\tprivate f : (l : A, r : A) => A;\r\n\tprivate out : StreamWithSend<A>;\r\n\tprivate accumValid : boolean;\r\n    private accum : A;\r\n    private verbose : boolean;\r\n    send_(a : A) {\r\n        if (this.accumValid)\r\n            this.accum = this.f(this.accum, a);\r\n        else {\r\n            Transaction.currentTransaction.prioritized(this.out.getVertex__(), () => {\r\n                this.out.send_(this.accum);\r\n                this.accumValid = false;\r\n                this.accum = null;\r\n            });\r\n            this.accum = a;\r\n            this.accumValid = true;\r\n        }\r\n    }\r\n}\r\n", "import { Lambda1, Lambda1_deps, Lambda1_toFunction,\r\n         Lambda2, Lambda2_deps, Lambda2_toFunction } from \"./Lambda\";\r\nimport { StreamWithSend } from \"./Stream\";\r\nimport { CoalesceHandler } from \"./CoalesceHandler\";\r\nimport { Transaction } from \"./Transaction\";\r\nimport { Vertex } from './Vertex';\r\n\r\n/**\r\n * A stream that allows values to be pushed into it, acting as an interface between the\r\n * world of I/O and the world of FRP. Code that exports StreamSinks for read-only use\r\n * should downcast to {@link Stream}.\r\n */\r\nexport class StreamSink<A> extends StreamWithSend<A> {\r\n    private disableListenCheck: boolean = false;\r\n\r\n    constructor(f? : ((l : A, r : A) => A) | Lambda2<A, A, A>) {\r\n        super();\r\n        if (!f)\r\n            f = <(l : A, r : A) => A>((l : A, r : A) => {\r\n                throw new Error(\"send() called more than once per transaction, which isn't allowed. Did you want to combine the events? Then pass a combining function to your StreamSink constructor.\");\r\n            });\r\n        this.coalescer = new CoalesceHandler<A>(f, this);\r\n    }\r\n\r\n    private coalescer : CoalesceHandler<A>;\r\n\r\n    send(a : A) : void {\r\n        Transaction.run<void>(\r\n            () => {\r\n                // We throw this error if we send into FRP logic that has been constructed\r\n                // but nothing is listening to it yet. We need to do it this way because\r\n                // it's the only way to manage memory in a language with no finalizers.\r\n                if (!this.disableListenCheck) {\r\n                    if (this.vertex.refCount() == 0) {\r\n                        throw new Error(\"send() was invoked before listeners were registered\");\r\n                    }\r\n                }\r\n                //\r\n                if (Transaction.currentTransaction.inCallback > 0)\r\n                    throw new Error(\"You are not allowed to use send() inside a Sodium callback\");\r\n                this.coalescer.send_(a);\r\n            }\r\n        )\r\n    }\r\n\r\n    listen_(target : Vertex,\r\n            h : (a : A) => void,\r\n            suppressEarlierFirings : boolean) : () => void {\r\n        let result = super.listen_(target, h, suppressEarlierFirings);\r\n        this.disableListenCheck = true;\r\n        return result;\r\n    }\r\n}\r\n", "import { Cell } from \"./Cell\";\r\nimport { Lazy } from \"./Lazy\";\r\nimport { LazyCell } from \"./LazyCell\";\r\nimport { Transaction } from \"./Transaction\";\r\nimport { StreamLoop } from \"./Stream\";\r\n\r\n/**\r\n * A forward reference for a {@link Cell} equivalent to the Cell that is referenced.\r\n */\r\nexport class CellLoop<A> extends LazyCell<A> {\r\n    constructor() {\r\n    \tsuper(null, new StreamLoop<A>());\r\n    }\r\n\r\n    /**\r\n     * Resolve the loop to specify what the CellLoop was a forward reference to. It\r\n     * must be invoked inside the same transaction as the place where the CellLoop is used.\r\n     * This requires you to create an explicit transaction with {@link Transaction#run(Lambda0)}\r\n     * or {@link Transaction#runVoid(Runnable)}.\r\n     */\r\n    loop(a_out : Cell<A>) : void {\r\n        const me = this;\r\n        Transaction.run(() => {\r\n            (<StreamLoop<A>>me.getStream__()).loop(a_out.getStream__());\r\n            me.lazyInitValue = a_out.sampleLazy();\r\n        });\r\n    }\r\n\r\n    sampleNoTrans__() : A\r\n    {\r\n        if (!(<StreamLoop<A>>this.getStream__()).assigned__)\r\n            throw new Error(\"CellLoop sampled before it was looped\");\r\n        return super.sampleNoTrans__();\r\n    }\r\n}\r\n", "import { Lambda1, Lambda1_deps, Lambda1_toFunction,\r\n         Lambda2, Lambda2_deps, Lambda2_toFunction } from \"./Lambda\";\r\nimport { Cell } from \"./Cell\";\r\nimport { StreamSink } from \"./StreamSink\";\r\nimport { Transaction } from \"./Transaction\";\r\n\r\n/**\r\n * A cell that allows values to be pushed into it, acting as an interface between the\r\n * world of I/O and the world of FRP. Code that exports CellSinks for read-only use\r\n * should downcast to {@link Cell}.\r\n */\r\nexport class CellSink<A> extends Cell<A> {\r\n    /**\r\n     * Construct a writable cell with the specified initial value. If multiple values are\r\n     * sent in the same transaction, the specified function is used to combine them.\r\n     *\r\n     * If the function is not supplied, then an exception will be thrown in this case.\r\n     */\r\n    constructor(initValue : A, f? : ((l : A, r : A) => A) | Lambda2<A, A, A>) {\r\n    \tsuper(initValue, new StreamSink<A>(f));\r\n    }\r\n\r\n    /**\r\n     * Send a value, modifying the value of the cell. send(A) may not be used inside\r\n     * handlers registered with {@link Stream#listen(Handler)} or {@link Cell#listen(Handler)}.\r\n     * An exception will be thrown, because CellSink is for interfacing I/O to FRP only.\r\n     * You are not meant to use this to define your own primitives.\r\n     * @param a Value to push into the cell.\r\n     */\r\n    send(a : A) : void {\r\n        (<StreamSink<A>>this.getStream__()).send(a);\r\n    }\r\n}\r\n", "import { Dictionary, Set } from 'typescript-collections';\r\nimport { Stream, StreamWithSend } from './Stream';\r\nimport { Vertex, Source } from './Vertex';\r\n\r\nexport class Router<A,K> {\r\n    private _inStream: Stream<A>;\r\n    private _table: Dictionary<K,StreamWithSend<A>[]>;\r\n    private _vertex: Vertex;\r\n\r\n    public constructor(inStream: Stream<A>, selector: (a: A) => K[], keyToStr?: (k: K)=>string) {\r\n        this._inStream = inStream;\r\n        this._table = new Dictionary(keyToStr);\r\n        this._vertex =\r\n            new Vertex(\r\n                \"Router\",\r\n                this._inStream.getVertex__().rank + 1, // <-- estimated rank only, may be adjusted by ensureBiggerThan\r\n                []\r\n            );\r\n        this._vertex.addSource(\r\n            new Source(\r\n                this._inStream.getVertex__(),\r\n                () =>\r\n                    this._inStream.listen_(\r\n                        this._vertex,\r\n                        (a: A) => {\r\n                            let ks = selector(a);\r\n                            let visited = new Set<K>(keyToStr);\r\n                            let outs: StreamWithSend<A>[] = [];\r\n                            for (let i = 0; i < ks.length; ++i) {\r\n                                let k = ks[i];\r\n                                if (visited.contains(k)) {\r\n                                    continue;\r\n                                }\r\n                                visited.add(k);\r\n                                let outs2 = this._table.getValue(k);\r\n                                if (outs2 != undefined) {\r\n                                    for (let j = 0; j < outs2.length; ++j) {\r\n                                        outs.push(outs2[j]);\r\n                                    }\r\n                                }\r\n                            }\r\n                            for (let i = 0; i < outs.length; ++i) {\r\n                                outs[i].send_(a);\r\n                            }\r\n                        },\r\n                        true\r\n                    )\r\n            )\r\n        );\r\n    }\r\n\r\n    public filterMatches(k: K): Stream<A> {\r\n        let out = new StreamWithSend<A>();\r\n        let vertex =\r\n            new Vertex(\r\n                \"Router::filterMatches\",\r\n                this._vertex.rank + 1, // <-- estimated rank only, may be adjusted by ensureBiggerThan\r\n                [\r\n                    new Source(\r\n                        this._vertex,\r\n                        () => {\r\n                            this._vertex.increment(out.getVertex__());\r\n                            let outs: StreamWithSend<A>[] = this._table.getValue(k);\r\n                            if (outs == undefined) {\r\n                                outs = [];\r\n                                this._table.setValue(k, outs);\r\n                            }\r\n                            outs.push(out);\r\n                            return () => {\r\n                                this._vertex.decrement(out.getVertex__());\r\n                                let outs2 = this._table.getValue(k);\r\n                                for (let i = outs2.length-1; i >= 0; --i) {\r\n                                    if (outs2[i] == out) {\r\n                                        outs2.splice(i, 1);\r\n                                        break;\r\n                                    }\r\n                                }\r\n                                if (outs2.length == 0) {\r\n                                    this._table.remove(k);\r\n                                }\r\n                            };\r\n                        }\r\n                    )\r\n                ]\r\n            );\r\n        out.setVertex__(vertex);\r\n        return out;\r\n    }\r\n}\r\n", "import { Vertex, Source } from \"./Vertex\";\r\nimport * as Collections from 'typescript-collections';\r\nimport { Stream, StreamWithSend } from \"./Stream\";\r\nimport { StreamSink } from \"./StreamSink\";\r\nimport { Cell } from \"./Cell\";\r\nimport { CellSink } from \"./CellSink\";\r\nimport { Transaction } from \"./Transaction\";\r\n\r\n/**\r\n * An interface for implementations of FRP timer systems.\r\n */\r\nexport abstract class TimerSystemImpl {\r\n    /**\r\n     * Set a timer that will execute the specified callback at the specified time.\r\n     * @return A function that can be used to cancel the timer.\r\n     */\r\n    abstract setTimer(t : number, callback : () => void) : () => void;\r\n\r\n    /**\r\n     * Return the current clock time.\r\n     */\r\n    abstract now() : number;\r\n}\r\n\r\nlet nextSeq : number = 0;\r\n\r\nclass Event {\r\n    constructor(t : number, sAlarm : StreamWithSend<number>) {\r\n        this.t = t;\r\n        this.sAlarm = sAlarm;\r\n        this.seq = ++nextSeq;\r\n    }\r\n    t : number;\r\n    sAlarm : StreamWithSend<number>;\r\n    seq : number;  // Used to guarantee uniqueness\r\n}\r\n\r\nexport class TimerSystem {\r\n    constructor(impl : TimerSystemImpl) {\r\n        Transaction.run(() => {\r\n            this.impl = impl;\r\n            this.tMinimum = 0;\r\n            const timeSnk = new CellSink<number>(impl.now());\r\n            this.time = timeSnk;\r\n            // A dummy listener to time to keep it alive even when there are no other listeners.\r\n            this.time.listen((t : number) => { });\r\n            Transaction.onStart(() => {\r\n                // Ensure the time is always increasing from the FRP's point of view.\r\n                const t = this.tMinimum = Math.max(this.tMinimum, impl.now());\r\n                // Pop and execute all events earlier than or equal to t (the current time).\r\n                while (true) {\r\n                    let ev : Event = null;\r\n                    if (!this.eventQueue.isEmpty()) {\r\n                        let mev = this.eventQueue.minimum();\r\n                        if (mev.t <= t) {\r\n                            ev = mev;\r\n                            // TO DO: Detect infinite loops!\r\n                        }\r\n                    }\r\n                    if (ev != null) {\r\n                        timeSnk.send(ev.t);\r\n                        Transaction.run(() => ev.sAlarm.send_(ev.t));\r\n                    }\r\n                    else\r\n                        break;\r\n                }\r\n                timeSnk.send(t);\r\n            });\r\n        });\r\n    }\r\n\r\n    private impl : TimerSystemImpl;\r\n    private tMinimum : number;  // A guard to allow us to guarantee that the time as\r\n                                // seen by the FRP is always increasing.\r\n\r\n    /**\r\n     * A cell giving the current clock time.\r\n     */\r\n    time : Cell<number>;\r\n\r\n    private eventQueue : Collections.BSTree<Event> = new Collections.BSTree<Event>((a, b) => {\r\n        if (a.t < b.t) return -1;\r\n        if (a.t > b.t) return 1;\r\n        if (a.seq < b.seq) return -1;\r\n        if (a.seq > b.seq) return 1;\r\n        return 0;\r\n    });\r\n\r\n    /**\r\n     * A timer that fires at the specified time, which can be null, meaning\r\n     * that the alarm is not set.\r\n     */\r\n    at(tAlarm : Cell<number>) : Stream<number> {\r\n        let current : Event = null,\r\n            cancelCurrent : () => void = null,\r\n            active : boolean = false,\r\n            tAl : number = null,\r\n            sampled : boolean = false;\r\n        const sAlarm = new StreamWithSend<number>(null),\r\n            updateTimer = () => {\r\n                if (cancelCurrent !== null) {\r\n                    cancelCurrent();\r\n                    this.eventQueue.remove(current);\r\n                }\r\n                cancelCurrent = null;\r\n                current = null;\r\n                if (active) {\r\n                    if (!sampled) {\r\n                        sampled = true;\r\n                        tAl = tAlarm.sampleNoTrans__();\r\n                    }\r\n                    if (tAl !== null) {\r\n                        current = new Event(tAl, sAlarm);\r\n                        this.eventQueue.add(current);\r\n                        cancelCurrent = this.impl.setTimer(tAl, () => {\r\n                                    // Correction to ensure the clock time appears to be >= the\r\n                                    // alarm time. It can be a few milliseconds early, and\r\n                                    // this breaks things otherwise, because it doesn't think\r\n                                    // it's time to fire the alarm yet.\r\n                                    this.tMinimum = Math.max(this.tMinimum, tAl);\r\n                                    // Open and close a transaction to trigger queued\r\n                                    // events to run.\r\n                                    Transaction.run(() => {});\r\n                                });\r\n                    }\r\n                }\r\n            };\r\n        sAlarm.setVertex__(new Vertex(\"at\", 0, [\r\n                new Source(\r\n                    tAlarm.getVertex__(),\r\n                    () => {\r\n                        active = true;\r\n                        sampled = false;\r\n                        Transaction.currentTransaction.prioritized(sAlarm.getVertex__(), updateTimer);\r\n                        const kill = tAlarm.getStream__().listen_(sAlarm.getVertex__(), (oAlarm : number) => {\r\n                            tAl = oAlarm;\r\n                            sampled = true;\r\n                            updateTimer();\r\n                        }, false);\r\n                        return () => {\r\n                            active = false;\r\n                            updateTimer();\r\n                            kill();\r\n                        };\r\n                    }\r\n                )\r\n            ]\r\n        ));\r\n        return sAlarm;\r\n    }\r\n}\r\n\r\n", "import { TimerSystem, TimerSystemImpl } from \"./TimerSystem\";\r\n\r\n/**\r\n * A timer system implementation using seconds as the time unit.\r\n */\r\nexport class SecondsTimerSystem extends TimerSystem {\r\n    constructor() {\r\n        super(new SecondsTimerSystemImpl());\r\n    }\r\n}\r\n\r\nclass SecondsTimerSystemImpl extends TimerSystemImpl {\r\n    /**\r\n     * Set a timer that will execute the specified callback at the specified time.\r\n     * @return A function that can be used to cancel the timer.\r\n     */\r\n    setTimer(t : number, callback : () => void) : () => void\r\n    {\r\n        let timeout = setTimeout(callback, Math.max((t - this.now()) * 1000, 0));\r\n        return () => { clearTimeout(timeout); }\r\n    }\r\n\r\n    /**\r\n     * Return the current clock time.\r\n     */\r\n    now() : number\r\n    {\r\n        return Date.now() * 0.001;\r\n    }\r\n}\r\n", "import { TimerSystem, TimerSystemImpl } from \"./TimerSystem\";\r\n\r\n/**\r\n * A timer system implementation using milliseconds as the time unit.\r\n */\r\nexport class MillisecondsTimerSystem extends TimerSystem {\r\n    constructor() {\r\n        super(new MillisecondsTimerSystemImpl());\r\n    }\r\n}\r\n\r\nclass MillisecondsTimerSystemImpl extends TimerSystemImpl {\r\n    /**\r\n     * Set a timer that will execute the specified callback at the specified time.\r\n     * @return A function that can be used to cancel the timer.\r\n     */\r\n    setTimer(t : number, callback : () => void) : () => void\r\n    {\r\n        let timeout = setTimeout(callback, Math.max(t - this.now(), 0));\r\n        return () => { clearTimeout(timeout); }\r\n    }\r\n\r\n    /**\r\n     * Return the current clock time.\r\n     */\r\n    now() : number\r\n    {\r\n        return Date.now();\r\n    }\r\n}\r\n", "import { Stream, StreamWithSend } from \"./Stream\";\r\nimport { Vertex, Source } from \"./Vertex\";\r\nimport { Transaction } from \"./Transaction\";\r\n\r\nexport class IOAction {\r\n    /*!\r\n     * Convert a function that performs asynchronous I/O taking input A\r\n     * and returning a value of type B into an I/O action of type\r\n     * (sa : Stream<A>) => Stream<B>\r\n     */\r\n    static fromAsync<A,B>(performIO : (a : A, result : (b : B) => void) => void)\r\n            : (sa : Stream<A>) => Stream<B> {\r\n        return (sa : Stream<A>) => {\r\n            const out = new StreamWithSend<B>(null);\r\n            out.setVertex__(new Vertex(\"map\", 0, [\r\n                    new Source(\r\n                        sa.getVertex__(),\r\n                        () => {\r\n                            return sa.listen_(out.getVertex__(), (a : A) => {\r\n                                performIO(a, (b : B) => {\r\n                                    Transaction.run(() => {\r\n                                        out.send_(b);\r\n                                    });\r\n                                });\r\n                            }, false);\r\n                        }\r\n                    )\r\n                ]\r\n            ));\r\n            return out;\r\n        }\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
